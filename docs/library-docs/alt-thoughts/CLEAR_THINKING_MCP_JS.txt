================================================
FILE: README.md
================================================
# Clear Thought MCP Server

[![smithery badge](https://smithery.ai/badge/@waldzellai/clear-thought)](https://smithery.ai/server/@waldzellai/clear-thought)

A Model Context Protocol (MCP) server that provides systematic thinking, mental models, and debugging approaches for enhanced problem-solving capabilities.

## Features

### Mental Models
- First Principles Thinking
- Opportunity Cost Analysis
- Error Propagation Understanding
- Rubber Duck Debugging
- Pareto Principle
- Occam's Razor
- And many more...

### Design Patterns
- Modular Architecture
- API Integration Patterns
- State Management
- Asynchronous Processing
- Scalability Considerations
- Security Best Practices
- Agentic Design Patterns

Note: Compatible with various modern web frameworks and architectures.

### Programming Paradigms
- Imperative Programming
- Procedural Programming
- Object-Oriented Programming
- Functional Programming
- Declarative Programming
- Logic Programming
- Event-Driven Programming
- Aspect-Oriented Programming
- Concurrent Programming
- Reactive Programming

### Debugging Approaches
- Binary Search
- Reverse Engineering
- Divide and Conquer
- Backtracking
- Cause Elimination
- Program Slicing
- Advanced debugging patterns

### Sequential Thinking
- Structured thought process
- Revision and branching support
- Progress tracking
- Context maintenance

## Tool Selection Guide

Each tool in the Clear Thought MCP Server has specific strengths. Here are some scenarios where each tool might be particularly useful:

### Mental Models
Best suited for:
- Initial problem understanding
- Breaking down complex systems
- Analyzing trade-offs
- Finding root causes
- Making strategic decisions

Example scenarios:
- Analyzing system architecture choices
- Evaluating competing solutions
- Understanding error patterns

### Design Patterns
Best suited for:
- Implementing proven solutions
- Structuring new features
- Ensuring maintainable code
- Scaling applications
- Managing technical debt

Example scenarios:
- Building new system components
- Refactoring existing code
- Implementing cross-cutting concerns

### Debugging Approaches
Best suited for:
- Troubleshooting issues
- Performance optimization
- System analysis
- Error resolution
- Quality assurance

Example scenarios:
- Fixing production issues
- Optimizing slow processes
- Resolving integration problems

### Sequential Thinking
Best suited for:
- Complex problem-solving
- Multi-step analysis
- Decision refinement
- Process improvement
- Comprehensive planning

Example scenarios:
- Planning major features
- Analyzing system-wide changes
- Making architectural decisions

Note: These are suggestions rather than rules. Tools can be used in any order or combination that best serves your needs.

## Installation

### Installing via Smithery

To install Clear Thought MCP Server for Claude Desktop automatically via [Smithery](https://smithery.ai/server/@waldzellai/clear-thought):

```bash
npx -y @smithery/cli install @waldzellai/clear-thought --client claude
```

### Manual Installation
```bash
npm install @waldzellai/clear-thought
```

Or run with npx:

```bash
npx @waldzellai/clear-thought
```

## Usage

### Mental Models
```typescript
const response = await mcp.callTool("mentalmodel", {
  modelName: "first_principles",
  problem: "How to implement a new feature?",
  steps: [
    "Break down the problem",
    "Analyze components",
    "Build solution"
  ]
});
```

### Debugging Approaches
```typescript
const response = await mcp.callTool("debuggingapproach", {
  approachName: "binary_search",
  issue: "Performance degradation in the system",
  steps: [
    "Identify performance metrics",
    "Locate bottleneck",
    "Implement solution"
  ]
});
```

### Sequential Thinking
```typescript
const response = await mcp.callTool("sequentialthinking", {
  thought: "Initial analysis of the problem",
  thoughtNumber: 1,
  totalThoughts: 3,
  nextThoughtNeeded: true
});
```

## Docker

Build the Docker image:

```bash
docker build -t waldzellai/clear-thought .
```

Run the container:

```bash
docker run -it waldzellai/clear-thought
```

## Development

1. Clone the repository
2. Install dependencies: `npm install`
3. Build the project: `npm run build`
4. Start the server: `npm start`

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT License - see LICENSE for details.

## Acknowledgments

- Based on the Model Context Protocol (MCP) by Anthropic, and uses the code for the sequentialthinking server
- Mental Models framework inspired by [James Clear's comprehensive guide to mental models](https://jamesclear.com/mental-models), which provides an excellent overview of how these thinking tools can enhance decision-making and problem-solving capabilities



================================================
FILE: CLAUDE.md
================================================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Model Context Protocol (MCP) server that provides systematic thinking, mental models, and debugging approaches for enhanced problem-solving capabilities. It enables Claude to use various cognitive tools including sequential thinking, mental models, and structured debugging approaches.

## Commands

### Building and Running

```bash
# Install dependencies
npm install

# Build the project
npm run build

# Start the server
npm start

# Watch mode (for development)
npm run dev 

# Build Docker image
npm run docker
# or directly
docker build -t waldzellai/clear-thought .

# Run Docker container
docker run -it waldzellai/clear-thought

# Deploy to Smithery
npm run deploy
```

### Cleaning

```bash
# Clean the build directory
npm run clean
```

## Code Architecture

This project is a TypeScript-based MCP server that follows the Model Context Protocol defined by Anthropic. It consists of several key components:

1. **Server Class Definitions** - Implementation of various thinking tools:
   - `SequentialThinkingServer` - Supports multi-step thinking with revision capabilities
   - `MentalModelServer` - Provides structured mental models like First Principles, Pareto, etc.
   - `DebuggingApproachServer` - Implements debugging methodologies like Binary Search

2. **Data Interfaces** - Type definitions for the various thinking tools:
   - `ThoughtData` - For sequential thinking steps
   - `MentalModelData` - For mental model applications
   - `DebuggingApproachData` - For debugging approaches

3. **Tool Definitions** - Registration of tools with the MCP framework:
   - Each tool has a name, description, and input schema
   - Consistent schemas for use by language models

4. **Request Handlers** - Logic to process tool requests:
   - Validates input data against schemas
   - Calls appropriate processing functions
   - Returns formatted JSON responses

5. **Server Transport** - Uses stdio for communication with the MCP client

The server is implemented as a single-file application (`index.ts`) that gets compiled to JavaScript using TypeScript.

## File Structure

- `index.ts` - Main server implementation
- `dist/` - Compiled JavaScript code
- `Dockerfile` - Container definition
- `smithery.yaml` - Smithery deployment configuration
- `package.json` - Node.js package definition

## Key Implementation Notes

1. **Tool Processing Flow**:
   - Data validation through type checking
   - Server class instance processes the data
   - Results are formatted and returned as JSON

2. **Thinking Tools**:
   - Sequential Thinking: Maintains thought history with support for branching and revision
   - Mental Models: Provides structure for applying specific reasoning frameworks
   - Debugging Approaches: Implements technical problem-solving methodologies
   - Additional cognitive tools: Collaborative reasoning, decision frameworks, metacognitive monitoring, etc.

3. **Configuration**:
   - The server uses TypeScript with ES2020 target
   - Uses stdio for communication with MCP clients
   - No configuration required to run

4. **Deployment**:
   - Can be deployed via Smithery
   - Available as a Docker container
   - Can be installed via npm


================================================
FILE: docker-compose.yml
================================================
version: '3.8'

services:
  clear-thought:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - PORT=3000
      - LOG_LEVEL=info
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped


================================================
FILE: Dockerfile
================================================
FROM node:18-alpine

# Install curl for health check
RUN apk add --no-cache curl

# Create app directory
WORKDIR /usr/src/app

# Copy package files first for better layer caching
COPY package*.json ./

# Install dependencies (skip prepare script)
RUN npm ci --ignore-scripts

# No longer needed - using standard MCP SDK patterns

# Copy source files
COPY . .

# Build the project
RUN npm run build

# Remove development dependencies
RUN npm prune --production

# Set executable permissions
RUN chmod +x build/index.js

# Expose port
EXPOSE 3000

# Run as non-root user
USER node

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# Start the HTTP server
CMD ["node", "build/src/smithery-entry.js"]

# Label the image
LABEL org.opencontainers.image.source="https://github.com/waldzellai/waldzell-mcp/tree/main/servers/server-clear-thought"
LABEL org.opencontainers.image.description="MCP server for systematic thinking, mental models, debugging approaches, and memory management"
LABEL org.opencontainers.image.licenses="MIT"



================================================
FILE: flake.lock
================================================
{
  "nodes": {
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1748370509,
        "narHash": "sha256-QlL8slIgc16W5UaI3w7xHQEP+Qmv/6vSNTpoZrrSlbk=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "4faa5f5321320e49a78ae7848582f684d64783e9",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-utils": "flake-utils",
        "nixpkgs": "nixpkgs"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
FILE: flake.nix
================================================
{
  description = "Development environment for my project";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
      in
      {
        # Development shell
        devShells.default = pkgs.mkShell {
          buildInputs = with pkgs; [
            # Programming languages
            nodejs_20
            python3
            go
            
            # Development tools
            git
            curl
            jq
            eza  # Modern ls replacement
            
            # Language-specific tools
            nodePackages.typescript
            nodePackages.pnpm
            python3Packages.pip
            
            # Optional: Database tools
            # postgresql
            # redis
          ];

          shellHook = ''
            echo "🚀 Development environment loaded!"
            echo "Node: $(node --version)"
            echo "Python: $(python --version)"
            echo "Go: $(go version)"
          '';

          # Environment variables
          env = {
            DATABASE_URL = "postgresql://localhost:5432/mydb";
            NODE_ENV = "development";
          };
        };

        # Optional: Define packages your project provides
        packages.default = pkgs.stdenv.mkDerivation {
          pname = "my-project";
          version = "0.1.0";
          src = ./.;
          
          buildPhase = ''
            # Your build commands here
            echo "Building project..."
          '';
          
          installPhase = ''
            mkdir -p $out/bin
            # Install your built artifacts
          '';
        };
      });
}


================================================
FILE: index.ts
================================================
#!/usr/bin/env node
// Import and run the server for direct execution
import { ClearThoughtMCPServer } from "./src/smithery-entry.js";

// Main execution
async function main() {
  const server = new ClearThoughtMCPServer();
  await server.start(parseInt(process.env.PORT || "3000", 10));
}

// Always run the server when index.ts is executed
main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 Anthropic, PBC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: package.json
================================================
{
    "name": "@waldzellai/clear-thought-onepointfive",
    "version": "0.0.5",
    "description": "Intermediate update to Waldzell's Clear Thought MCP server",
    "license": "MIT",
    "author": "Waldzell AI",
    "homepage": "https://github.com/waldzellai/waldzell-mcp/tree/main/packages/server-clear-thought",
    "bugs": {
        "url": "https://github.com/waldzellai/waldzell-mcp/issues"
    },
    "type": "module",
    "bin": {
        "clear-thought-mcp": "build/index.js"
    },
    "files": [
        "dist",
        "src",
        "smithery.yaml",
        "README.md",
        "LICENSE"
    ],
    "scripts": {
        "build": "tsc && tsc-alias && chmod +x build/index.js",
        "build:smithery": "npx @smithery/cli build",
        "test": "vitest",
        "test:coverage": "vitest --coverage",
        "clean": "rm -rf build dist",
        "typecheck": "tsc --noEmit",
        "lint": "echo \"No linting configured\" && exit 0",
        "docker:build": "docker build -t waldzellai/clear-thought .",
        "docker:run": "docker run -p 3000:3000 waldzellai/clear-thought",
        "dev": "tsx watch src/index.ts",
        "dev:http": "tsx src/smithery-entry.ts",
        "start": "node build/index.js",
        "start:dev": "tsx src/index.ts",
        "start:http": "node build/src/smithery-entry.js",
        "prepare": "npm run build",
        "watch": "tsc --watch",
        "prebuild": "npm run clean",
        "prepublishOnly": "npm run build",
        "dev:watch": "npm run watch",
        "deploy": "smithery deploy",
        "inspector": "npx @modelcontextprotocol/inspector build/index.js"
    },
    "repository": {
        "type": "git",
        "url": "git+https://github.com/waldzellai/waldzell-mcp.git"
    },
    "dependencies": {
        "@modelcontextprotocol/sdk": "^1.5.0",
        "@smithery/sdk": "^1.4.3",
        "express": "^4.18.2",
        "lodash": "^4.17.21",
        "zod": "^3.25.27",
        "zod-to-json-schema": "^3.22.4",
        "dotenv": "^16.5.0",
        "cors": "^2.8.5",
        "cookie-parser": "^1.4.7",
        "ajv": "^8.17.1",
        "json-schema": "^0.4.0"
    },
    "devDependencies": {
        "@types/express": "^4.17.21",
        "@types/lodash": "^4.14.202",
        "@types/node": "^22",
        "@types/supertest": "^6.0.2",
        "@vitest/coverage-v8": "^1.2.0",
        "supertest": "^6.3.4",
        "tsx": "^4.7.0",
        "typescript": "^5.3.3",
        "vitest": "^1.2.0",
        "tsc-alias": "^1.8.16",
        "@types/cors": "^2.8.18",
        "@types/cookie-parser": "^1.4.8",
        "@types/json-schema": "^7.0.15"
    },
    "keywords": [
        "mcp",
        "sequential-thinking",
        "mental-models",
        "debugging",
        "problem-solving",
        "ai",
        "cognitive-tools"
    ],
    "engines": {
        "node": ">=18"
    },
    "main": "./build/index.js",
    "module": "./build/src/smithery-entry.js",
    "exports": {
        ".": {
            "import": "./dist/index.js",
            "require": "./dist/index.js"
        },
        "./server": {
            "import": "./dist/server.js",
            "require": "./dist/server.js"
        },
        "./tools/*": {
            "import": "./dist/tools/*.js",
            "require": "./dist/tools/*.js"
        }
    }
}



================================================
FILE: smithery-build.ts
================================================
// Entry point for Smithery builds - exports the server creator function directly
export { default } from './src/index.js';
export { configSchema } from './src/index.js';


================================================
FILE: smithery.yaml
================================================
runtime: "typescript" 


================================================
FILE: tsconfig.alias.json
================================================
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}


================================================
FILE: tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "coverage", "tests", "**/*.test.ts", "**/*.spec.ts"]
}


================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2023"],
    "rootDir": ".",
    "outDir": "./build",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "allowSyntheticDefaultImports": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*", "index.ts"],
  "exclude": ["node_modules", "build", "dist", "coverage", "**/*.test.ts", "tests/**/*"]
}



================================================
FILE: vitest.config.ts
================================================
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'dist/',
        'tests/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/mockData.ts'
      ]
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    },
    extensions: ['.ts', '.js']
  }
});


================================================
FILE: .dockerignore
================================================
node_modules
dist
.git
.gitignore
.dockerignore
Dockerfile
docker-compose.yml
.env
.env.*
*.log
.DS_Store
coverage
.nyc_output
.vscode
.idea
*.md
!README.md
temp
trees
specs
tests
__tests__
*.test.ts
*.spec.ts
.github
.eslintrc*
.prettierrc*


================================================
FILE: .npmignore
================================================
# Source files
src/
*.ts
!dist/**/*.d.ts

# Configuration
tsconfig.json
.gitignore
.npmignore

# Development files
.vscode/
.idea/
.claude/
claude_code_mcp_config.json
mcp_config_claude_code.json

# Testing
tests/
coverage/
.nyc_output/
*.test.*
*.spec.*

# Documentation development
specs/
trees/

# Build tools
Dockerfile
smithery.yaml
flake.nix
flake.lock

# Backup files
*.bak
*.bak2
index-old-bloated.ts

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# OS
.DS_Store
Thumbs.db

# Temporary files
*.tmp
*.temp
.cache/
systemprompt-mcp-reddit/


================================================
FILE: src/config.ts
================================================
/**
 * Configuration schema and types for the Clear Thought MCP server
 */

import { z } from 'zod';

/**
 * Configuration schema for the Clear Thought MCP server
 * 
 * @property debug - Enable debug logging (default: false)
 * @property maxThoughtsPerSession - Maximum number of thoughts allowed per session (default: 100)
 * @property sessionTimeout - Session timeout in milliseconds (default: 3600000 - 1 hour)
 * @property enableMetrics - Enable metrics collection (default: false)
 */
export const ServerConfigSchema = z.object({
  debug: z.boolean().default(false).describe('Enable debug logging'),
  maxThoughtsPerSession: z.number().min(1).max(1000).default(100).describe('Maximum number of thoughts allowed per session'),
  sessionTimeout: z.number().min(60000).default(3600000).describe('Session timeout in milliseconds'),
  enableMetrics: z.boolean().default(false).describe('Enable metrics collection')
});

/**
 * Inferred type from the configuration schema
 */
export type ServerConfig = z.infer<typeof ServerConfigSchema>;

/**
 * Default configuration values
 */
export const defaultConfig: ServerConfig = {
  debug: false,
  maxThoughtsPerSession: 100,
  sessionTimeout: 3600000, // 1 hour
  enableMetrics: false
};

/**
 * Validates and parses configuration
 * @param config - Raw configuration object
 * @returns Validated configuration
 * @throws {z.ZodError} If configuration is invalid
 */
export function parseConfig(config: unknown): ServerConfig {
  return ServerConfigSchema.parse(config);
}

/**
 * Safely parses configuration with fallback to defaults
 * @param config - Raw configuration object
 * @returns Validated configuration or default configuration
 */
export function safeParseConfig(config: unknown): ServerConfig {
  const result = ServerConfigSchema.safeParse(config);
  if (result.success) {
    return result.data;
  }
  
  console.warn('Invalid configuration provided, using defaults:', result.error.issues);
  return defaultConfig;
}


================================================
FILE: src/dev.ts
================================================
#!/usr/bin/env node
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import createClearThoughtServer from './index.js';

async function runDev() {
  const transport = new StdioServerTransport();
  
  // Create server with dev config
  const server = createClearThoughtServer({
    sessionId: 'dev-' + Date.now(),
    config: {
      debug: true,
      maxThoughtsPerSession: 100,
      sessionTimeout: 3600000,
      enableMetrics: false
    }
  });
  
  await server.connect(transport);
  console.error('[Clear Thought] Development server running on stdio');
  console.error('[Clear Thought] Session ID:', 'dev-' + Date.now());
  console.error('[Clear Thought] Debug mode: enabled');
  console.error('[Clear Thought] Press Ctrl+C to exit');
  
  // Handle shutdown
  process.on('SIGINT', () => {
    console.error('\n[Clear Thought] Shutting down...');
    transport.close();
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    console.error('\n[Clear Thought] Received SIGTERM, shutting down...');
    transport.close();
    process.exit(0);
  });
}

// Only run if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runDev().catch(error => {
    console.error('[Clear Thought] Fatal error:', error);
    process.exit(1);
  });
}


================================================
FILE: src/index.ts
================================================
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { SessionState } from './state/SessionState.js';
import { ServerConfigSchema, type ServerConfig } from './config.js';
import { registerTools } from './tools/index.js';

// Export the config schema for Smithery
export { ServerConfigSchema as configSchema } from './config.js';

/**
 * Creates a Clear Thought MCP server instance for a specific session
 * @param sessionId - Unique identifier for this session
 * @param config - Server configuration
 * @returns Server instance configured for this session
 */
export default function createClearThoughtServer({
  sessionId,
  config
}: {
  sessionId: string;
  config: z.infer<typeof ServerConfigSchema>
}): Server {
  // Create a new MCP server instance for each session
  const mcpServer = new McpServer({
    name: 'clear-thought',
    version: '0.0.5'
  });

  // Initialize session state
  const sessionState = new SessionState(sessionId, config);

  // Register all tools for this session
  registerTools(mcpServer, sessionState);
  
  // Return the underlying Server instance for Smithery SDK
  return mcpServer.server;
}



================================================
FILE: src/server.ts
================================================
import { createStatefulServer } from '@smithery/sdk/server/stateful.js';
import createClearThoughtServer from './index.js';
import { ServerConfigSchema, type ServerConfig } from './config.js';
import type { Request, Response, NextFunction } from 'express';
import { z } from 'zod';

// Create the Express app with stateful server
const { app } = createStatefulServer<ServerConfig>(createClearThoughtServer, {
  schema: ServerConfigSchema as z.ZodSchema<ServerConfig>
});

// Add health check endpoint
app.get('/health', (req: Request, res: Response) => {
  res.json({ 
    status: 'ok', 
    service: 'clear-thought-mcp',
    timestamp: new Date().toISOString() 
  });
});

// Error handling middleware
app.use((err: any, req: Request, res: Response, next: NextFunction) => {
  console.error('Server error:', err);
  res.status(500).json({ 
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

// Get port from environment or use default
const PORT = process.env.PORT || 3000;

// Start the server
const server = app.listen(PORT, () => {
  console.log(`Clear Thought MCP server running on port ${PORT}`);
  console.log(`Health check available at http://localhost:${PORT}/health`);
  console.log(`MCP endpoint available at http://localhost:${PORT}/mcp`);
});

// Graceful shutdown handling
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  server.close(() => {
    process.exit(1);
  });
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  server.close(() => {
    process.exit(1);
  });
});


================================================
FILE: src/smithery-entry.ts
================================================
#!/usr/bin/env node
import { config } from "dotenv";
import express from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import { randomUUID } from "node:crypto";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import {
  ListResourcesRequestSchema,
  ReadResourceRequestSchema,
  ListToolsRequestSchema,
  CallToolRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { handleListResources, handleResourceCall } from "./handlers/resource-handlers.js";
import { handleListTools, handleToolCall } from "./handlers/tool-handlers.js";
import { serverConfig, serverCapabilities } from "./config/server-config.js";

config();

export class ClearThoughtMCPServer {
  private app: express.Application;
  private mcpServer: Server;
  private mcpTransport: StreamableHTTPServerTransport;

  constructor() {
    // Initialize MCP server
    this.mcpServer = new Server(serverConfig as any, serverCapabilities as any);
    this.setupMCPHandlers();

    // Initialize MCP transport
    this.mcpTransport = new StreamableHTTPServerTransport({
      sessionIdGenerator: () => randomUUID(),
    });

    this.setupMCPTransport();

    // Initialize Express app
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
  }

  private setupMCPHandlers(): void {
    this.mcpServer.setRequestHandler(ListResourcesRequestSchema, handleListResources);
    this.mcpServer.setRequestHandler(ReadResourceRequestSchema, handleResourceCall);
    this.mcpServer.setRequestHandler(ListToolsRequestSchema, handleListTools);
    this.mcpServer.setRequestHandler(CallToolRequestSchema, handleToolCall);
  }

  private setupMCPTransport(): void {
    this.mcpServer.connect(this.mcpTransport);
  }

  private setupMiddleware(): void {
    this.app.use(cors({ origin: true, credentials: true }));
    this.app.use(cookieParser());
  }

  private setupRoutes(): void {
    // MCP endpoint using SDK transport
    this.app.all("/mcp", async (req, res) => {
      await this.mcpTransport.handleRequest(req, res);
    });

    // Health check
    this.app.get("/health", (req, res) => {
      res.json({
        status: "ok",
        service: "clear-thought-mcp-server",
        transport: "http",
        capabilities: {
          mcp: true,
          tools: [
            "sequentialthinking",
            "mentalmodel",
            "debuggingapproach",
            "collaborativereasoning",
            "decisionframework",
            "metacognitivemonitoring",
            "scientificmethod",
            "structuredargumentation",
            "visualreasoning"
          ]
        },
      });
    });

    // Root endpoint
    this.app.get("/", (req, res) => {
      const baseUrl = `${req.protocol}://${req.get("host")}`;
      res.json({
        service: "Clear Thought MCP Server",
        version: "0.0.5",
        transport: "http",
        endpoints: {
          mcp: `${baseUrl}/mcp`,
          health: `${baseUrl}/health`,
        },
      });
    });
  }

  public async start(port: number = 3000): Promise<void> {
    this.app.listen(port, () => {
      const baseHost = `localhost:${port}`;
      console.log(`🚀 Clear Thought MCP Server (HTTP Transport) running on port ${port}`);
      console.log(`📡 MCP endpoint: http://${baseHost}/mcp`);
      console.log(`❤️  Health: http://${baseHost}/health`);
    });
  }
}

// Main execution for standalone mode
async function main() {
  const server = new ClearThoughtMCPServer();
  await server.start(parseInt(process.env.PORT || "3000", 10));
}

// Run the server in standalone mode if executed directly
// Use process.argv to check if this is the main module
const isMainModule = process.argv[1] && process.argv[1].endsWith('smithery-entry.ts');
if (isMainModule) {
  main().catch((error) => {
    console.error("Fatal error:", error);
    process.exit(1);
  });
}

// Export for Smithery - returns the MCP server instance
export default function () {
  // Create MCP server
  const mcpServer = new Server(serverConfig as any, serverCapabilities as any);
  
  // Set up handlers
  mcpServer.setRequestHandler(ListResourcesRequestSchema, handleListResources);
  mcpServer.setRequestHandler(ReadResourceRequestSchema, handleResourceCall);
  mcpServer.setRequestHandler(ListToolsRequestSchema, handleListTools);
  mcpServer.setRequestHandler(CallToolRequestSchema, handleToolCall);
  
  // For HTTP support, we need to start the HTTP server in the background
  const httpServer = new ClearThoughtMCPServer();
  httpServer.start(parseInt(process.env.PORT || "3000", 10)).catch((error) => {
    console.error("Failed to start HTTP server:", error);
  });
  
  // Return the MCP server instance for Smithery
  return mcpServer;
}


================================================
FILE: src/config/server-config.ts
================================================
export const serverConfig = {
  name: "clear-thought",
  version: "0.0.5",
};

export const serverCapabilities = {
  tools: {},
  resources: {},
};


================================================
FILE: src/constants/tools.ts
================================================
import { Tool } from "@modelcontextprotocol/sdk/types.js";
import { sequentialThinking } from "./tool/sequential-thinking.js";
import { mentalModel } from "./tool/mental-model.js";
import { debuggingApproach } from "./tool/debugging-approach.js";
import { collaborativeReasoning } from "./tool/collaborative-reasoning.js";
import { decisionFramework } from "./tool/decision-framework.js";
import { metacognitiveMonitoring } from "./tool/metacognitive-monitoring.js";
import { scientificMethod } from "./tool/scientific-method.js";
import { structuredArgumentation } from "./tool/structured-argumentation.js";
import { visualReasoning } from "./tool/visual-reasoning.js";

export const TOOL_ERROR_MESSAGES = {
  UNKNOWN_TOOL: "Unknown tool:",
  TOOL_CALL_FAILED: "Tool call failed:",
} as const;

export const TOOLS: Tool[] = [
  sequentialThinking,
  mentalModel,
  debuggingApproach,
  collaborativeReasoning,
  decisionFramework,
  metacognitiveMonitoring,
  scientificMethod,
  structuredArgumentation,
  visualReasoning,
];


================================================
FILE: src/constants/tool/collaborative-reasoning.ts
================================================
import { Tool } from "@modelcontextprotocol/sdk/types.js";

export const collaborativeReasoning: Tool = {
  name: "collaborativereasoning",
  description: "Facilitate collaborative reasoning with multiple perspectives and personas",
  inputSchema: {
    type: "object",
    properties: {
      topic: {
        type: "string",
        description: "Topic for collaborative reasoning"
      },
      personas: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            expertise: { type: "array", items: { type: "string" } },
            background: { type: "string" },
            perspective: { type: "string" },
            biases: { type: "array", items: { type: "string" } },
            communication: {
              type: "object",
              properties: {
                style: { type: "string", enum: ["formal", "casual", "technical", "creative"] },
                tone: { type: "string", enum: ["analytical", "supportive", "challenging", "neutral"] }
              },
              required: ["style", "tone"]
            }
          },
          required: ["id", "name", "expertise", "background", "perspective", "biases", "communication"]
        }
      },
      contributions: {
        type: "array",
        items: {
          type: "object",
          properties: {
            personaId: { type: "string" },
            content: { type: "string" },
            type: { type: "string", enum: ["observation", "question", "insight", "concern", "suggestion", "challenge", "synthesis"] },
            confidence: { type: "number", minimum: 0, maximum: 1 },
            referenceIds: { type: "array", items: { type: "string" } }
          },
          required: ["personaId", "content", "type", "confidence"]
        }
      },
      stage: {
        type: "string",
        enum: ["problem-definition", "ideation", "critique", "integration", "decision", "reflection"]
      },
      activePersonaId: { type: "string" },
      sessionId: { type: "string" },
      iteration: { type: "number" },
      nextContributionNeeded: { type: "boolean" }
    },
    required: ["topic", "personas", "contributions", "stage", "activePersonaId", "sessionId", "iteration", "nextContributionNeeded"]
  }
};


================================================
FILE: src/constants/tool/debugging-approach.ts
================================================
import { Tool } from "@modelcontextprotocol/sdk/types.js";

export const debuggingApproach: Tool = {
  name: "debuggingapproach",
  description: "Apply systematic debugging approaches to identify and resolve issues",
  inputSchema: {
    type: "object",
    properties: {
      approachName: {
        type: "string",
        enum: ["binary_search", "reverse_engineering", "divide_conquer", "backtracking", "cause_elimination", "program_slicing"],
        description: "Debugging approach"
      },
      steps: {
        type: "array",
        items: {
          type: "string"
        },
        description: "Steps taken to debug"
      },
      resolution: {
        type: "string",
        description: "How the issue was resolved"
      }
    },
    required: ["approachName", "steps", "resolution"]
  }
};


================================================
FILE: src/constants/tool/decision-framework.ts
================================================
import { Tool } from "@modelcontextprotocol/sdk/types.js";

export const decisionFramework: Tool = {
  name: "decisionframework",
  description: "Apply structured decision-making frameworks",
  inputSchema: {
    type: "object",
    properties: {
      decisionStatement: {
        type: "string",
        description: "The decision to be made"
      },
      options: {
        type: "array",
        items: {
          type: "object"
        },
        description: "Available options"
      },
      analysisType: {
        type: "string",
        description: "Type of analysis framework"
      },
      stage: {
        type: "string",
        description: "Current stage in the decision process"
      },
      decisionId: {
        type: "string",
        description: "Unique identifier for this decision"
      },
      iteration: {
        type: "number",
        description: "Current iteration"
      },
      nextStageNeeded: {
        type: "boolean",
        description: "Whether to proceed to the next stage"
      }
    },
    required: ["decisionStatement", "options", "analysisType", "stage", "decisionId", "iteration", "nextStageNeeded"]
  }
};


================================================
FILE: src/constants/tool/mental-model.ts
================================================
import { Tool } from "@modelcontextprotocol/sdk/types.js";

export const mentalModel: Tool = {
  name: "mentalmodel",
  description: "Apply mental models to analyze problems systematically",
  inputSchema: {
    type: "object",
    properties: {
      modelName: {
        type: "string",
        enum: ["first_principles", "opportunity_cost", "error_propagation", "rubber_duck", "pareto_principle", "occams_razor"],
        description: "Name of the mental model"
      },
      steps: {
        type: "array",
        items: {
          type: "string"
        },
        description: "Steps to apply the model"
      },
      conclusion: {
        type: "string",
        description: "Conclusions drawn"
      }
    },
    required: ["modelName", "steps", "conclusion"]
  }
};


================================================
FILE: src/constants/tool/metacognitive-monitoring.ts
================================================
import { Tool } from "@modelcontextprotocol/sdk/types.js";

export const metacognitiveMonitoring: Tool = {
  name: "metacognitivemonitoring",
  description: "Monitor and assess thinking processes and knowledge",
  inputSchema: {
    type: "object",
    properties: {
      task: {
        type: "string",
        description: "Task being monitored"
      },
      stage: {
        type: "string",
        description: "Current stage of metacognitive monitoring"
      },
      overallConfidence: {
        type: "number",
        description: "Overall confidence level (0-1)"
      },
      uncertaintyAreas: {
        type: "array",
        items: {
          type: "string"
        },
        description: "Areas of uncertainty"
      },
      recommendedApproach: {
        type: "string",
        description: "Recommended approach based on assessment"
      },
      monitoringId: {
        type: "string",
        description: "Unique identifier for this monitoring session"
      },
      iteration: {
        type: "number",
        description: "Current iteration"
      },
      nextAssessmentNeeded: {
        type: "boolean",
        description: "Whether another assessment is needed"
      }
    },
    required: ["task", "stage", "overallConfidence", "uncertaintyAreas", "recommendedApproach", "monitoringId", "iteration", "nextAssessmentNeeded"]
  }
};


================================================
FILE: src/constants/tool/scientific-method.ts
================================================
import { Tool } from "@modelcontextprotocol/sdk/types.js";

export const scientificMethod: Tool = {
  name: "scientificmethod",
  description: "Apply scientific method for systematic inquiry",
  inputSchema: {
    type: "object",
    properties: {
      stage: {
        type: "string",
        description: "Current stage of scientific method"
      },
      inquiryId: {
        type: "string",
        description: "Unique identifier for this inquiry"
      },
      iteration: {
        type: "number",
        description: "Current iteration"
      },
      nextStageNeeded: {
        type: "boolean",
        description: "Whether to proceed to next stage"
      }
    },
    required: ["stage", "inquiryId", "iteration", "nextStageNeeded"]
  }
};


================================================
FILE: src/constants/tool/sequential-thinking.ts
================================================
import { Tool } from "@modelcontextprotocol/sdk/types.js";

export const sequentialThinking: Tool = {
  name: "sequentialthinking",
  description: "Process sequential thoughts with branching, revision, and memory management capabilities",
  inputSchema: {
    type: "object",
    properties: {
      thought: {
        type: "string",
        description: "The thought content"
      },
      thoughtNumber: {
        type: "number",
        description: "Current thought number in sequence"
      },
      totalThoughts: {
        type: "number",
        description: "Total expected thoughts in sequence"
      },
      nextThoughtNeeded: {
        type: "boolean",
        description: "Whether the next thought is needed"
      },
      isRevision: {
        type: "boolean",
        description: "Whether this is a revision of a previous thought"
      },
      revisesThought: {
        type: "number",
        description: "Which thought number this revises"
      },
      branchFromThought: {
        type: "number",
        description: "Which thought this branches from"
      },
      branchId: {
        type: "string",
        description: "Unique identifier for this branch"
      },
      needsMoreThoughts: {
        type: "boolean",
        description: "Whether more thoughts are needed"
      }
    },
    required: ["thought", "thoughtNumber", "totalThoughts", "nextThoughtNeeded"]
  }
};


================================================
FILE: src/constants/tool/structured-argumentation.ts
================================================
import { Tool } from "@modelcontextprotocol/sdk/types.js";

export const structuredArgumentation: Tool = {
  name: "structuredargumentation",
  description: "Construct and analyze structured arguments",
  inputSchema: {
    type: "object",
    properties: {
      claim: {
        type: "string",
        description: "The main claim or thesis"
      },
      premises: {
        type: "array",
        items: {
          type: "string"
        },
        description: "Supporting premises"
      },
      conclusion: {
        type: "string",
        description: "The conclusion drawn"
      },
      argumentType: {
        type: "string",
        description: "Type of argument structure"
      },
      confidence: {
        type: "number",
        description: "Confidence in the argument (0-1)"
      },
      nextArgumentNeeded: {
        type: "boolean",
        description: "Whether another argument is needed"
      }
    },
    required: ["claim", "premises", "conclusion", "argumentType", "confidence", "nextArgumentNeeded"]
  }
};


================================================
FILE: src/constants/tool/visual-reasoning.ts
================================================
import { Tool } from "@modelcontextprotocol/sdk/types.js";

export const visualReasoning: Tool = {
  name: "visualreasoning",
  description: "Process visual reasoning and diagram operations",
  inputSchema: {
    type: "object",
    properties: {
      operation: {
        type: "string",
        description: "Operation being performed"
      },
      diagramId: {
        type: "string",
        description: "Unique identifier for the diagram"
      },
      diagramType: {
        type: "string",
        description: "Type of diagram"
      },
      iteration: {
        type: "number",
        description: "Current iteration"
      },
      nextOperationNeeded: {
        type: "boolean",
        description: "Whether another operation is needed"
      }
    },
    required: ["operation", "diagramId", "diagramType", "iteration", "nextOperationNeeded"]
  }
};


================================================
FILE: src/handlers/resource-handlers.ts
================================================
import {
  ListResourcesRequest,
  ListResourcesResult,
  ReadResourceRequest,
  ReadResourceResult,
} from "@modelcontextprotocol/sdk/types.js";

export async function handleListResources(
  request: ListResourcesRequest
): Promise<ListResourcesResult> {
  return {
    resources: [
      {
        uri: "clearthought://memory",
        name: "Thinking Memory",
        description: "Access stored thoughts, mental models, and reasoning patterns",
        mimeType: "application/json"
      }
    ]
  };
}

export async function handleResourceCall(
  request: ReadResourceRequest
): Promise<ReadResourceResult> {
  if (request.params.uri === "clearthought://memory") {
    return {
      contents: [
        {
          uri: "clearthought://memory",
          mimeType: "application/json",
          text: JSON.stringify({
            thoughts: [],
            models: [],
            decisions: [],
            timestamp: new Date().toISOString()
          }, null, 2)
        }
      ]
    };
  }
  
  throw new Error(`Unknown resource: ${request.params.uri}`);
}


================================================
FILE: src/handlers/tool-handlers.ts
================================================
import {
  CallToolRequest,
  CallToolResult,
  ListToolsRequest,
  ListToolsResult,
} from "@modelcontextprotocol/sdk/types.js";
import { TOOLS, TOOL_ERROR_MESSAGES } from "../constants/tools.js";
import { validateWithErrors } from "../utils/validation.js";
import { JSONSchema7 } from "json-schema";
import {
  handleSequentialThinking,
  handleMentalModel,
  handleDebuggingApproach,
  handleCollaborativeReasoning,
  handleDecisionFramework,
  handleMetacognitiveMonitoring,
  handleScientificMethod,
  handleStructuredArgumentation,
  handleVisualReasoning,
  SequentialThinkingArgs,
  MentalModelArgs,
  DebuggingApproachArgs,
  CollaborativeReasoningArgs,
  DecisionFrameworkArgs,
  MetacognitiveMonitoringArgs,
  ScientificMethodArgs,
  StructuredArgumentationArgs,
  VisualReasoningArgs,
} from "./tools/index.js";

type ToolArgs = {
  sequentialthinking: SequentialThinkingArgs;
  mentalmodel: MentalModelArgs;
  debuggingapproach: DebuggingApproachArgs;
  collaborativereasoning: CollaborativeReasoningArgs;
  decisionframework: DecisionFrameworkArgs;
  metacognitivemonitoring: MetacognitiveMonitoringArgs;
  scientificmethod: ScientificMethodArgs;
  structuredargumentation: StructuredArgumentationArgs;
  visualreasoning: VisualReasoningArgs;
};

export async function handleListTools(request: ListToolsRequest): Promise<ListToolsResult> {
  try {
    const tools = [...TOOLS].sort((a, b) => a.name.localeCompare(b.name));
    return { tools };
  } catch (error) {
    return { tools: TOOLS };
  }
}

export async function handleToolCall(
  request: CallToolRequest,
): Promise<CallToolResult> {
  try {
    if (!request.params.arguments) {
      throw new Error("Arguments are required");
    }

    const tool = TOOLS.find((t) => t.name === request.params.name);
    if (!tool) {
      throw new Error(`${TOOL_ERROR_MESSAGES.UNKNOWN_TOOL} ${request.params.name}`);
    }

    validateWithErrors(request.params.arguments, tool.inputSchema as JSONSchema7);
    const args = request.params.arguments as unknown as ToolArgs[keyof ToolArgs];

    switch (request.params.name) {
      case "sequentialthinking":
        return await handleSequentialThinking(args as SequentialThinkingArgs);
      case "mentalmodel":
        return await handleMentalModel(args as MentalModelArgs);
      case "debuggingapproach":
        return await handleDebuggingApproach(args as DebuggingApproachArgs);
      case "collaborativereasoning":
        return await handleCollaborativeReasoning(args as CollaborativeReasoningArgs);
      case "decisionframework":
        return await handleDecisionFramework(args as DecisionFrameworkArgs);
      case "metacognitivemonitoring":
        return await handleMetacognitiveMonitoring(args as MetacognitiveMonitoringArgs);
      case "scientificmethod":
        return await handleScientificMethod(args as ScientificMethodArgs);
      case "structuredargumentation":
        return await handleStructuredArgumentation(args as StructuredArgumentationArgs);
      case "visualreasoning":
        return await handleVisualReasoning(args as VisualReasoningArgs);
      default:
        throw new Error(`${TOOL_ERROR_MESSAGES.UNKNOWN_TOOL} ${request.params.name}`);
    }
  } catch (error) {
    throw error;
  }
}


================================================
FILE: src/handlers/tools/collaborative-reasoning.ts
================================================
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

export interface CollaborativeReasoningArgs {
  topic: string;
  personas: Array<{
    id: string;
    name: string;
    expertise: string[];
    background: string;
    perspective: string;
    biases: string[];
    communication: {
      style: "formal" | "casual" | "technical" | "creative";
      tone: "analytical" | "supportive" | "challenging" | "neutral";
    };
  }>;
  contributions: Array<{
    personaId: string;
    content: string;
    type: "observation" | "question" | "insight" | "concern" | "suggestion" | "challenge" | "synthesis";
    confidence: number;
    referenceIds?: string[];
  }>;
  stage: "problem-definition" | "ideation" | "critique" | "integration" | "decision" | "reflection";
  activePersonaId: string;
  sessionId: string;
  iteration: number;
  nextContributionNeeded: boolean;
}

export async function handleCollaborativeReasoning(
  args: CollaborativeReasoningArgs
): Promise<CallToolResult> {
  const {
    topic,
    stage,
    activePersonaId,
    contributions,
    nextContributionNeeded,
    sessionId,
    iteration
  } = args;

  const result = {
    topic,
    stage,
    activePersonaId,
    contributionsCount: contributions.length,
    nextContributionNeeded,
    sessionId,
    iteration,
    status: "success",
    timestamp: new Date().toISOString()
  };

  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(result, null, 2)
      }
    ]
  };
}


================================================
FILE: src/handlers/tools/debugging-approach.ts
================================================
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

export interface DebuggingApproachArgs {
  approachName: "binary_search" | "reverse_engineering" | "divide_conquer" | "backtracking" | "cause_elimination" | "program_slicing";
  steps: string[];
  resolution: string;
}

export async function handleDebuggingApproach(
  args: DebuggingApproachArgs
): Promise<CallToolResult> {
  const { approachName, steps, resolution } = args;

  // Apply the debugging approach
  const result = {
    approachName,
    status: "success",
    hasSteps: steps.length > 0,
    hasResolution: !!resolution,
    stepsCount: steps.length,
    debuggingApplied: true,
    timestamp: new Date().toISOString()
  };

  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(result, null, 2)
      }
    ]
  };
}


================================================
FILE: src/handlers/tools/decision-framework.ts
================================================
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

export interface DecisionFrameworkArgs {
  decisionStatement: string;
  options: Array<any>;
  analysisType: string;
  stage: string;
  decisionId: string;
  iteration: number;
  nextStageNeeded: boolean;
}

export async function handleDecisionFramework(
  args: DecisionFrameworkArgs
): Promise<CallToolResult> {
  const {
    decisionId,
    stage,
    analysisType,
    options,
    nextStageNeeded,
    iteration
  } = args;

  const result = {
    decisionId,
    stage,
    analysisType,
    optionsCount: options.length,
    nextStageNeeded,
    iteration,
    status: "success",
    timestamp: new Date().toISOString()
  };

  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(result, null, 2)
      }
    ]
  };
}


================================================
FILE: src/handlers/tools/index.ts
================================================
export * from "./sequential-thinking.js";
export * from "./mental-model.js";
export * from "./debugging-approach.js";
export * from "./collaborative-reasoning.js";
export * from "./decision-framework.js";
export * from "./metacognitive-monitoring.js";
export * from "./scientific-method.js";
export * from "./structured-argumentation.js";
export * from "./visual-reasoning.js";


================================================
FILE: src/handlers/tools/mental-model.ts
================================================
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

export interface MentalModelArgs {
  modelName: "first_principles" | "opportunity_cost" | "error_propagation" | "rubber_duck" | "pareto_principle" | "occams_razor";
  steps: string[];
  conclusion: string;
}

export async function handleMentalModel(
  args: MentalModelArgs
): Promise<CallToolResult> {
  const { modelName, steps, conclusion } = args;

  // Apply the mental model
  const result = {
    modelName,
    status: "success",
    hasSteps: steps.length > 0,
    hasConclusion: !!conclusion,
    stepsCount: steps.length,
    modelApplied: true,
    timestamp: new Date().toISOString()
  };

  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(result, null, 2)
      }
    ]
  };
}


================================================
FILE: src/handlers/tools/metacognitive-monitoring.ts
================================================
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

export interface MetacognitiveMonitoringArgs {
  task: string;
  stage: string;
  overallConfidence: number;
  uncertaintyAreas: string[];
  recommendedApproach: string;
  monitoringId: string;
  iteration: number;
  nextAssessmentNeeded: boolean;
}

export async function handleMetacognitiveMonitoring(
  args: MetacognitiveMonitoringArgs
): Promise<CallToolResult> {
  const {
    task,
    stage,
    overallConfidence,
    uncertaintyAreas,
    nextAssessmentNeeded,
    monitoringId,
    iteration
  } = args;

  const result = {
    task,
    stage,
    overallConfidence,
    uncertaintyCount: uncertaintyAreas.length,
    nextAssessmentNeeded,
    monitoringId,
    iteration,
    status: "success",
    timestamp: new Date().toISOString()
  };

  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(result, null, 2)
      }
    ]
  };
}


================================================
FILE: src/handlers/tools/scientific-method.ts
================================================
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

export interface ScientificMethodArgs {
  stage: string;
  inquiryId: string;
  iteration: number;
  nextStageNeeded: boolean;
}

export async function handleScientificMethod(
  args: ScientificMethodArgs
): Promise<CallToolResult> {
  const { inquiryId, stage, iteration, nextStageNeeded } = args;

  const result = {
    inquiryId,
    stage,
    iteration,
    nextStageNeeded,
    status: "success",
    timestamp: new Date().toISOString()
  };

  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(result, null, 2)
      }
    ]
  };
}


================================================
FILE: src/handlers/tools/sequential-thinking.ts
================================================
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

export interface SequentialThinkingArgs {
  thought: string;
  thoughtNumber: number;
  totalThoughts: number;
  nextThoughtNeeded: boolean;
  isRevision?: boolean;
  revisesThought?: number;
  branchFromThought?: number;
  branchId?: string;
  needsMoreThoughts?: boolean;
}

export async function handleSequentialThinking(
  args: SequentialThinkingArgs
): Promise<CallToolResult> {
  const {
    thought,
    thoughtNumber,
    totalThoughts,
    nextThoughtNeeded,
    isRevision,
    revisesThought,
    branchFromThought,
    branchId,
    needsMoreThoughts
  } = args;

  // Process the sequential thinking
  const result = {
    thoughtNumber,
    totalThoughts,
    status: "success",
    nextThoughtNeeded,
    isRevision: isRevision || false,
    revisesThought,
    branchFromThought,
    branchId,
    needsMoreThoughts: needsMoreThoughts || false,
    message: `Processed thought ${thoughtNumber}/${totalThoughts}`,
    timestamp: new Date().toISOString()
  };

  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(result, null, 2)
      }
    ]
  };
}


================================================
FILE: src/handlers/tools/structured-argumentation.ts
================================================
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

export interface StructuredArgumentationArgs {
  claim: string;
  premises: string[];
  conclusion: string;
  argumentType: string;
  confidence: number;
  nextArgumentNeeded: boolean;
}

export async function handleStructuredArgumentation(
  args: StructuredArgumentationArgs
): Promise<CallToolResult> {
  const {
    claim,
    premises,
    argumentType,
    confidence,
    nextArgumentNeeded
  } = args;

  const result = {
    claim,
    premisesCount: premises.length,
    argumentType,
    confidence,
    nextArgumentNeeded,
    status: "success",
    timestamp: new Date().toISOString()
  };

  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(result, null, 2)
      }
    ]
  };
}


================================================
FILE: src/handlers/tools/visual-reasoning.ts
================================================
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";

export interface VisualReasoningArgs {
  operation: string;
  diagramId: string;
  diagramType: string;
  iteration: number;
  nextOperationNeeded: boolean;
}

export async function handleVisualReasoning(
  args: VisualReasoningArgs
): Promise<CallToolResult> {
  const {
    diagramId,
    diagramType,
    operation,
    iteration,
    nextOperationNeeded
  } = args;

  const result = {
    diagramId,
    diagramType,
    operation,
    iteration,
    nextOperationNeeded,
    status: "success",
    timestamp: new Date().toISOString()
  };

  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(result, null, 2)
      }
    ]
  };
}


================================================
FILE: src/state/SessionState.ts
================================================
/**
 * Main session state management class for the Clear Thought MCP server
 * 
 * This class manages all thinking session data and provides centralized
 * access to different types of thinking tools and their data.
 */

import { ServerConfig } from '../config.js';
import { 
  ThoughtData, 
  MentalModelData, 
  DebuggingSession,
  CollaborativeSession,
  DecisionData,
  MetacognitiveData,
  ScientificInquiryData,
  CreativeData,
  SystemsData,
  VisualData,
  SessionExport,
  ArgumentData,
  SocraticData
} from '../types/index.js';

// Import all stores
import { ThoughtStore } from './stores/ThoughtStore.js';
import { MentalModelStore } from './stores/MentalModelStore.js';
import { DebuggingStore } from './stores/DebuggingStore.js';
import { CollaborativeStore } from './stores/CollaborativeStore.js';
import { DecisionStore } from './stores/DecisionStore.js';
import { MetacognitiveStore } from './stores/MetacognitiveStore.js';
import { ScientificStore } from './stores/ScientificStore.js';
import { CreativeStore } from './stores/CreativeStore.js';
import { SystemsStore } from './stores/SystemsStore.js';
import { VisualStore } from './stores/VisualStore.js';

/**
 * Comprehensive session statistics
 */
export interface SessionStatistics {
  sessionId: string;
  createdAt: Date;
  lastAccessedAt: Date;
  thoughtCount: number;
  toolsUsed: string[];
  totalOperations: number;
  isActive: boolean;
  remainingThoughts: number;
  stores: {
    thoughts: Record<string, any>;
    mentalModels: Record<string, any>;
    debugging: Record<string, any>;
    collaborative: Record<string, any>;
    decisions: Record<string, any>;
    metacognitive: Record<string, any>;
    scientific: Record<string, any>;
    creative: Record<string, any>;
    systems: Record<string, any>;
    visual: Record<string, any>;
  };
}

/**
 * Main session state class
 */
export class SessionState {
  /** Unique session identifier */
  readonly sessionId: string;
  
  /** Server configuration */
  private readonly config: ServerConfig;
  
  /** Session creation timestamp */
  private readonly createdAt: Date;
  
  /** Last access timestamp */
  private lastAccessedAt: Date;
  
  /** Timeout timer reference */
  private timeoutTimer?: NodeJS.Timeout;
  
  /** Data stores */
  private readonly thoughtStore: ThoughtStore;
  private readonly mentalModelStore: MentalModelStore;
  private readonly debuggingStore: DebuggingStore;
  private readonly collaborativeStore: CollaborativeStore;
  private readonly decisionStore: DecisionStore;
  private readonly metacognitiveStore: MetacognitiveStore;
  private readonly scientificStore: ScientificStore;
  private readonly creativeStore: CreativeStore;
  private readonly systemsStore: SystemsStore;
  private readonly visualStore: VisualStore;
  
  /**
   * Create a new session state
   * @param sessionId - Unique identifier for this session
   * @param config - Server configuration
   */
  constructor(sessionId: string, config: ServerConfig) {
    this.sessionId = sessionId;
    this.config = config;
    this.createdAt = new Date();
    this.lastAccessedAt = new Date();
    
    // Initialize all stores
    this.thoughtStore = new ThoughtStore();
    this.mentalModelStore = new MentalModelStore();
    this.debuggingStore = new DebuggingStore();
    this.collaborativeStore = new CollaborativeStore();
    this.decisionStore = new DecisionStore();
    this.metacognitiveStore = new MetacognitiveStore();
    this.scientificStore = new ScientificStore();
    this.creativeStore = new CreativeStore();
    this.systemsStore = new SystemsStore();
    this.visualStore = new VisualStore();
    
    // Start timeout timer
    this.resetTimeout();
  }
  
  /**
   * Reset the session timeout
   */
  private resetTimeout(): void {
    if (this.timeoutTimer) {
      clearTimeout(this.timeoutTimer);
    }
    
    this.timeoutTimer = setTimeout(() => {
      this.cleanup();
    }, this.config.sessionTimeout);
    
    this.lastAccessedAt = new Date();
  }
  
  /**
   * Touch the session to prevent timeout
   */
  touch(): void {
    this.resetTimeout();
  }
  
  // ============================================================================
  // Thought Management
  // ============================================================================
  
  /**
   * Add a new thought
   * @param thought - The thought data
   * @returns True if added, false if limit reached
   */
  addThought(thought: ThoughtData): boolean {
    this.touch();
    
    // Check thought limit
    if (this.thoughtStore.size() >= this.config.maxThoughtsPerSession) {
      return false;
    }
    
    const id = `thought-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.thoughtStore.add(id, thought);
    return true;
  }
  
  /**
   * Get all thoughts
   */
  getThoughts(): ThoughtData[] {
    this.touch();
    return this.thoughtStore.getAll();
  }
  
  /**
   * Get remaining thought capacity
   */
  getRemainingThoughts(): number {
    return Math.max(0, this.config.maxThoughtsPerSession - this.thoughtStore.size());
  }
  
  // ============================================================================
  // Mental Model Management
  // ============================================================================
  
  /**
   * Add a mental model application
   */
  addMentalModel(model: MentalModelData): void {
    this.touch();
    const id = `model-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.mentalModelStore.add(id, model);
  }
  
  /**
   * Get all mental model applications
   */
  getMentalModels(): MentalModelData[] {
    this.touch();
    return this.mentalModelStore.getAll();
  }
  
  // ============================================================================
  // Debugging Management
  // ============================================================================
  
  /**
   * Add a debugging session
   */
  addDebuggingSession(session: DebuggingSession): void {
    this.touch();
    const id = `debug-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.debuggingStore.add(id, session);
  }
  
  /**
   * Get all debugging sessions
   */
  getDebuggingSessions(): DebuggingSession[] {
    this.touch();
    return this.debuggingStore.getAll();
  }
  
  // ============================================================================
  // Collaborative Reasoning Management
  // ============================================================================
  
  /**
   * Add a collaborative session
   */
  addCollaborativeSession(session: CollaborativeSession): void {
    this.touch();
    const id = `collab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.collaborativeStore.add(id, session);
  }
  
  /**
   * Get all collaborative sessions
   */
  getCollaborativeSessions(): CollaborativeSession[] {
    this.touch();
    return this.collaborativeStore.getAll();
  }
  
  /**
   * Get a specific collaborative session by ID
   */
  getCollaborativeSession(sessionId: string): CollaborativeSession | undefined {
    this.touch();
    return this.collaborativeStore.find(s => s.sessionId === sessionId);
  }
  
  // ============================================================================
  // Decision Framework Management
  // ============================================================================
  
  /**
   * Add a decision session
   */
  addDecision(decision: DecisionData): void {
    this.touch();
    const id = `decision-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.decisionStore.add(id, decision);
  }
  
  /**
   * Get all decision sessions
   */
  getDecisions(): DecisionData[] {
    this.touch();
    return this.decisionStore.getAll();
  }
  
  /**
   * Get a specific decision by ID
   */
  getDecision(decisionId: string): DecisionData | undefined {
    this.touch();
    return this.decisionStore.find(d => d.decisionId === decisionId);
  }
  
  // ============================================================================
  // Metacognitive Monitoring Management
  // ============================================================================
  
  /**
   * Add a metacognitive monitoring session
   */
  addMetacognitive(session: MetacognitiveData): void {
    this.touch();
    const id = `meta-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.metacognitiveStore.add(id, session);
  }
  
  /**
   * Get all metacognitive sessions
   */
  getMetacognitiveSessions(): MetacognitiveData[] {
    this.touch();
    return this.metacognitiveStore.getAll();
  }
  
  /**
   * Get a specific metacognitive session by ID
   */
  getMetacognitiveSession(monitoringId: string): MetacognitiveData | undefined {
    this.touch();
    return this.metacognitiveStore.find(m => m.monitoringId === monitoringId);
  }
  
  // ============================================================================
  // Scientific Method Management
  // ============================================================================
  
  /**
   * Add a scientific inquiry session
   */
  addScientificInquiry(inquiry: ScientificInquiryData): void {
    this.touch();
    const id = `sci-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.scientificStore.add(id, inquiry);
  }
  
  /**
   * Get all scientific inquiry sessions
   */
  getScientificInquiries(): ScientificInquiryData[] {
    this.touch();
    return this.scientificStore.getAll();
  }
  
  /**
   * Get a specific scientific inquiry by ID
   */
  getScientificInquiry(inquiryId: string): ScientificInquiryData | undefined {
    this.touch();
    return this.scientificStore.find(i => i.inquiryId === inquiryId);
  }
  
  // ============================================================================
  // Creative Thinking Management
  // ============================================================================
  
  /**
   * Add a creative thinking session
   */
  addCreativeSession(session: CreativeData): void {
    this.touch();
    const id = `creative-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.creativeStore.add(id, session);
  }
  
  /**
   * Get all creative sessions
   */
  getCreativeSessions(): CreativeData[] {
    this.touch();
    return this.creativeStore.getAll();
  }
  
  // ============================================================================
  // Systems Thinking Management
  // ============================================================================
  
  /**
   * Add a systems thinking session
   */
  addSystemsAnalysis(system: SystemsData): void {
    this.touch();
    const id = `systems-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.systemsStore.add(id, system);
  }
  
  /**
   * Get all systems analyses
   */
  getSystemsAnalyses(): SystemsData[] {
    this.touch();
    return this.systemsStore.getAll();
  }
  
  // ============================================================================
  // Visual Reasoning Management
  // ============================================================================
  
  /**
   * Add a visual reasoning operation
   */
  addVisualOperation(visual: VisualData): void {
    this.touch();
    const id = `visual-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.visualStore.add(id, visual);
  }
  
  /**
   * Get all visual operations
   */
  getVisualOperations(): VisualData[] {
    this.touch();
    return this.visualStore.getAll();
  }
  
  /**
   * Get visual operations for a specific diagram
   */
  getVisualDiagram(diagramId: string): VisualData[] {
    this.touch();
    return this.visualStore.getByDiagram(diagramId);
  }
  
  // ============================================================================
  // Argumentation Support (Socratic method uses ArgumentData)
  // ============================================================================
  
  /**
   * Add a Socratic/argumentation session
   * Note: Since SocraticData extends ArgumentData, we can store it directly
   */
  addArgumentation(argument: ArgumentData | SocraticData): void {
    this.touch();
    // For now, we'll store these in the creative store as a placeholder
    // In a real implementation, you might want a dedicated ArgumentStore
    const session: CreativeData = {
      prompt: argument.claim,
      ideas: argument.premises,
      techniques: ['socratic-method'],
      connections: [],
      insights: [argument.conclusion],
      sessionId: argument.sessionId,
      iteration: argument.iteration,
      nextIdeaNeeded: argument.nextArgumentNeeded
    };
    this.addCreativeSession(session);
  }
  
  // ============================================================================
  // Statistics and Export
  // ============================================================================
  
  /**
   * Get comprehensive session statistics
   */
  getStats(): SessionStatistics {
    this.touch();
    
    const toolsUsed = new Set<string>();
    let totalOperations = 0;
    
    // Check which tools have been used
    if (this.thoughtStore.size() > 0) {
      toolsUsed.add('sequential-thinking');
      totalOperations += this.thoughtStore.size();
    }
    if (this.mentalModelStore.size() > 0) {
      toolsUsed.add('mental-models');
      totalOperations += this.mentalModelStore.size();
    }
    if (this.debuggingStore.size() > 0) {
      toolsUsed.add('debugging');
      totalOperations += this.debuggingStore.size();
    }
    if (this.collaborativeStore.size() > 0) {
      toolsUsed.add('collaborative-reasoning');
      totalOperations += this.collaborativeStore.size();
    }
    if (this.decisionStore.size() > 0) {
      toolsUsed.add('decision-framework');
      totalOperations += this.decisionStore.size();
    }
    if (this.metacognitiveStore.size() > 0) {
      toolsUsed.add('metacognitive-monitoring');
      totalOperations += this.metacognitiveStore.size();
    }
    if (this.scientificStore.size() > 0) {
      toolsUsed.add('scientific-method');
      totalOperations += this.scientificStore.size();
    }
    if (this.creativeStore.size() > 0) {
      toolsUsed.add('creative-thinking');
      totalOperations += this.creativeStore.size();
    }
    if (this.systemsStore.size() > 0) {
      toolsUsed.add('systems-thinking');
      totalOperations += this.systemsStore.size();
    }
    if (this.visualStore.size() > 0) {
      toolsUsed.add('visual-reasoning');
      totalOperations += this.visualStore.size();
    }
    
    return {
      sessionId: this.sessionId,
      createdAt: this.createdAt,
      lastAccessedAt: this.lastAccessedAt,
      thoughtCount: this.thoughtStore.size(),
      toolsUsed: Array.from(toolsUsed),
      totalOperations,
      isActive: !!this.timeoutTimer,
      remainingThoughts: this.getRemainingThoughts(),
      stores: {
        thoughts: this.thoughtStore.getStatistics(),
        mentalModels: this.mentalModelStore.getStatistics(),
        debugging: this.debuggingStore.getStatistics(),
        collaborative: this.collaborativeStore.getStatistics(),
        decisions: this.decisionStore.getStatistics(),
        metacognitive: this.metacognitiveStore.getStatistics(),
        scientific: this.scientificStore.getStatistics(),
        creative: this.creativeStore.getStatistics(),
        systems: this.systemsStore.getStatistics(),
        visual: this.visualStore.getStatistics()
      }
    };
  }
  
  /**
   * Export session data
   * @param storeType - Optional specific store to export
   * @returns Exportable session data
   */
  export(storeType?: string): SessionExport | SessionExport[] {
    this.touch();
    
    const baseExport = {
      version: '1.0.0',
      timestamp: new Date().toISOString(),
      sessionId: this.sessionId
    };
    
    // Export specific store if requested
    if (storeType) {
      const exports: SessionExport[] = [];
      
      switch (storeType) {
        case 'thoughts':
          this.thoughtStore.getAll().forEach(thought => {
            exports.push({
              ...baseExport,
              sessionType: 'sequential',
              data: thought
            });
          });
          break;
          
        case 'mentalModels':
          this.mentalModelStore.getAll().forEach(model => {
            exports.push({
              ...baseExport,
              sessionType: 'mental-model',
              data: model
            });
          });
          break;
          
        // Add other cases as needed...
      }
      
      return exports.length === 1 ? exports[0] : exports;
    }
    
    // Export all data
    const allExports: SessionExport[] = [];
    
    // Add exports from all stores
    this.thoughtStore.getAll().forEach(thought => {
      allExports.push({
        ...baseExport,
        sessionType: 'sequential',
        data: thought
      });
    });
    
    this.mentalModelStore.getAll().forEach(model => {
      allExports.push({
        ...baseExport,
        sessionType: 'mental-model',
        data: model
      });
    });
    
    // Continue for all other stores...
    
    return allExports;
  }
  
  /**
   * Import session data
   * @param data - The session export data to import
   */
  import(data: SessionExport | SessionExport[]): void {
    this.touch();
    
    const imports = Array.isArray(data) ? data : [data];
    
    imports.forEach(item => {
      switch (item.sessionType) {
        case 'sequential':
          this.addThought(item.data as ThoughtData);
          break;
          
        case 'mental-model':
          this.addMentalModel(item.data as MentalModelData);
          break;
          
        case 'debugging':
          this.addDebuggingSession(item.data as DebuggingSession);
          break;
          
        case 'collaborative':
          this.addCollaborativeSession(item.data as CollaborativeSession);
          break;
          
        case 'decision':
          this.addDecision(item.data as DecisionData);
          break;
          
        case 'metacognitive':
          this.addMetacognitive(item.data as MetacognitiveData);
          break;
          
        case 'scientific':
          this.addScientificInquiry(item.data as ScientificInquiryData);
          break;
          
        case 'creative':
          this.addCreativeSession(item.data as CreativeData);
          break;
          
        case 'systems':
          this.addSystemsAnalysis(item.data as SystemsData);
          break;
          
        case 'visual':
          this.addVisualOperation(item.data as VisualData);
          break;
      }
    });
  }
  
  /**
   * Cleanup session data and stop timers
   */
  cleanup(): void {
    if (this.timeoutTimer) {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = undefined;
    }
    
    // Clear all stores
    this.thoughtStore.clear();
    this.mentalModelStore.clear();
    this.debuggingStore.clear();
    this.collaborativeStore.clear();
    this.decisionStore.clear();
    this.metacognitiveStore.clear();
    this.scientificStore.clear();
    this.creativeStore.clear();
    this.systemsStore.clear();
    this.visualStore.clear();
  }
  
  /**
   * Check if session is still active
   */
  isActive(): boolean {
    return !!this.timeoutTimer;
  }
}


================================================
FILE: src/state/stores/BaseStore.ts
================================================
/**
 * Base abstract class for all data stores in the Clear Thought MCP server
 * 
 * This class provides common functionality for storing and managing
 * different types of thinking session data.
 */

/**
 * Generic base store for managing collections of typed data
 * @template T - The type of data this store manages
 */
export abstract class BaseStore<T> {
  /** Internal storage map */
  protected data: Map<string, T>;
  
  /** Store name for logging and debugging */
  protected readonly storeName: string;
  
  constructor(storeName: string) {
    this.storeName = storeName;
    this.data = new Map();
  }
  
  /**
   * Add a new item to the store
   * @param id - Unique identifier for the item
   * @param item - The item to store
   */
  abstract add(id: string, item: T): void;
  
  /**
   * Get all items from the store
   * @returns Array of all stored items
   */
  abstract getAll(): T[];
  
  /**
   * Clear all items from the store
   */
  abstract clear(): void;
  
  /**
   * Get a specific item by ID
   * @param id - The item's unique identifier
   * @returns The item if found, undefined otherwise
   */
  get(id: string): T | undefined {
    return this.data.get(id);
  }
  
  /**
   * Check if an item exists
   * @param id - The item's unique identifier
   * @returns True if the item exists
   */
  has(id: string): boolean {
    return this.data.has(id);
  }
  
  /**
   * Delete a specific item
   * @param id - The item's unique identifier
   * @returns True if the item was deleted
   */
  delete(id: string): boolean {
    return this.data.delete(id);
  }
  
  /**
   * Get the number of items in the store
   * @returns The count of items
   */
  size(): number {
    return this.data.size;
  }
  
  /**
   * Export all data for persistence
   * @returns Serializable representation of the store
   */
  export(): Record<string, T> {
    const result: Record<string, T> = {};
    this.data.forEach((value, key) => {
      result[key] = value;
    });
    return result;
  }
  
  /**
   * Import data from a serialized representation
   * @param data - The data to import
   */
  import(data: Record<string, T>): void {
    this.clear();
    Object.entries(data).forEach(([key, value]) => {
      this.add(key, value);
    });
  }
  
  /**
   * Get all keys in the store
   * @returns Array of all keys
   */
  keys(): string[] {
    return Array.from(this.data.keys());
  }
  
  /**
   * Get all values in the store
   * @returns Array of all values
   */
  values(): T[] {
    return Array.from(this.data.values());
  }
  
  /**
   * Iterate over all entries
   * @param callback - Function to call for each entry
   */
  forEach(callback: (value: T, key: string) => void): void {
    this.data.forEach(callback);
  }
  
  /**
   * Filter items based on a predicate
   * @param predicate - Function to test each item
   * @returns Array of items that match the predicate
   */
  filter(predicate: (item: T) => boolean): T[] {
    return this.values().filter(predicate);
  }
  
  /**
   * Find the first item matching a predicate
   * @param predicate - Function to test each item
   * @returns The first matching item or undefined
   */
  find(predicate: (item: T) => boolean): T | undefined {
    return this.values().find(predicate);
  }
  
  /**
   * Update an existing item
   * @param id - The item's unique identifier
   * @param updater - Function to update the item
   * @returns True if the item was updated
   */
  update(id: string, updater: (item: T) => T): boolean {
    const item = this.get(id);
    if (item) {
      this.add(id, updater(item));
      return true;
    }
    return false;
  }
}


================================================
FILE: src/state/stores/CollaborativeStore.ts
================================================
/**
 * Store for managing collaborative reasoning sessions
 */

import { BaseStore } from './BaseStore.js';
import { CollaborativeSession, PersonaData, ContributionData } from '../../types/index.js';

/**
 * Specialized store for managing collaborative reasoning sessions
 */
export class CollaborativeStore extends BaseStore<CollaborativeSession> {
  /** Map of topics to their sessions */
  private topicSessions: Map<string, CollaborativeSession[]>;
  
  /** Map of persona IDs to their participation sessions */
  private personaParticipation: Map<string, Set<string>>;
  
  constructor() {
    super('CollaborativeStore');
    this.topicSessions = new Map();
    this.personaParticipation = new Map();
  }
  
  /**
   * Add a new collaborative session
   * @param id - Unique identifier
   * @param session - The collaborative session data
   */
  add(id: string, session: CollaborativeSession): void {
    this.data.set(id, session);
    
    // Track by topic
    const sessions = this.topicSessions.get(session.topic) || [];
    sessions.push(session);
    this.topicSessions.set(session.topic, sessions);
    
    // Track persona participation
    session.personas.forEach(persona => {
      const participation = this.personaParticipation.get(persona.id) || new Set();
      participation.add(id);
      this.personaParticipation.set(persona.id, participation);
    });
  }
  
  /**
   * Get all collaborative sessions
   * @returns Array of all sessions
   */
  getAll(): CollaborativeSession[] {
    return Array.from(this.data.values());
  }
  
  /**
   * Clear all data
   */
  clear(): void {
    this.data.clear();
    this.topicSessions.clear();
    this.personaParticipation.clear();
  }
  
  /**
   * Get sessions by topic
   * @param topic - The topic to search for
   * @returns Array of sessions on that topic
   */
  getByTopic(topic: string): CollaborativeSession[] {
    // Exact match
    const exact = this.topicSessions.get(topic) || [];
    
    // Also find partial matches
    const partial = this.filter(session => 
      session.topic.toLowerCase().includes(topic.toLowerCase()) &&
      !exact.includes(session)
    );
    
    return [...exact, ...partial];
  }
  
  /**
   * Get sessions where a specific persona participated
   * @param personaId - The persona identifier
   * @returns Array of sessions with that persona
   */
  getByPersona(personaId: string): CollaborativeSession[] {
    const sessionIds = this.personaParticipation.get(personaId);
    if (!sessionIds) return [];
    
    return Array.from(sessionIds)
      .map(id => this.get(id))
      .filter((session): session is CollaborativeSession => session !== undefined);
  }
  
  /**
   * Get active sessions (those needing next contribution)
   * @returns Array of active sessions
   */
  getActiveSessions(): CollaborativeSession[] {
    return this.filter(session => session.nextContributionNeeded);
  }
  
  /**
   * Get sessions with consensus
   * @returns Array of sessions that reached consensus
   */
  getConsensusSession(): CollaborativeSession[] {
    return this.filter(session => 
      !!(session.consensusPoints && session.consensusPoints.length > 0)
    );
  }
  
  /**
   * Get sessions with unresolved disagreements
   * @returns Array of sessions with active disagreements
   */
  getDisagreementSessions(): CollaborativeSession[] {
    return this.filter(session => 
      !!(session.disagreements && 
      session.disagreements.some(d => !d.resolution))
    );
  }
  
  /**
   * Get contribution statistics for a session
   * @param sessionId - The session identifier
   * @returns Statistics about contributions
   */
  getContributionStats(sessionId: string): Record<string, any> | undefined {
    const session = this.get(sessionId);
    if (!session) return undefined;
    
    const stats: Record<string, any> = {
      totalContributions: session.contributions.length,
      byType: {} as Record<string, number>,
      byPersona: {} as Record<string, number>,
      averageConfidence: 0
    };
    
    let totalConfidence = 0;
    
    session.contributions.forEach(contrib => {
      // Count by type
      stats.byType[contrib.type] = (stats.byType[contrib.type] || 0) + 1;
      
      // Count by persona
      const personaName = session.personas.find(p => p.id === contrib.personaId)?.name || 'Unknown';
      stats.byPersona[personaName] = (stats.byPersona[personaName] || 0) + 1;
      
      totalConfidence += contrib.confidence;
    });
    
    stats.averageConfidence = session.contributions.length > 0 
      ? totalConfidence / session.contributions.length 
      : 0;
    
    return stats;
  }
  
  /**
   * Get overall statistics
   * @returns Comprehensive statistics
   */
  getStatistics(): Record<string, any> {
    const sessions = this.getAll();
    
    return {
      totalSessions: sessions.length,
      activeSessions: this.getActiveSessions().length,
      sessionsWithConsensus: this.getConsensusSession().length,
      sessionsWithDisagreements: this.getDisagreementSessions().length,
      averageContributions: sessions.length > 0
        ? sessions.reduce((sum, s) => sum + s.contributions.length, 0) / sessions.length
        : 0,
      averagePersonas: sessions.length > 0
        ? sessions.reduce((sum, s) => sum + s.personas.length, 0) / sessions.length
        : 0,
      stageDistribution: this.getStageDistribution()
    };
  }
  
  /**
   * Get distribution of sessions by stage
   * @returns Count of sessions in each stage
   */
  private getStageDistribution(): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    this.forEach(session => {
      distribution[session.stage] = (distribution[session.stage] || 0) + 1;
    });
    
    return distribution;
  }
}


================================================
FILE: src/state/stores/CreativeStore.ts
================================================
/**
 * Store for managing creative thinking data
 */

import { BaseStore } from './BaseStore.js';
import { CreativeData } from '../../types/index.js';

/**
 * Specialized store for managing creative thinking sessions
 */
export class CreativeStore extends BaseStore<CreativeData> {
  /** Map of prompts to their sessions */
  private promptSessions: Map<string, CreativeData[]>;
  
  /** Map of techniques to sessions using them */
  private techniqueSessions: Map<string, Set<string>>;
  
  constructor() {
    super('CreativeStore');
    this.promptSessions = new Map();
    this.techniqueSessions = new Map();
  }
  
  /**
   * Add a new creative thinking session
   * @param id - Unique identifier
   * @param session - The creative data
   */
  add(id: string, session: CreativeData): void {
    this.data.set(id, session);
    
    // Track by prompt (first 50 chars as key)
    const promptKey = session.prompt.substring(0, 50);
    const sessions = this.promptSessions.get(promptKey) || [];
    sessions.push(session);
    this.promptSessions.set(promptKey, sessions);
    
    // Track by techniques
    session.techniques.forEach(technique => {
      const sessionIds = this.techniqueSessions.get(technique) || new Set();
      sessionIds.add(id);
      this.techniqueSessions.set(technique, sessionIds);
    });
  }
  
  /**
   * Get all creative sessions
   * @returns Array of all sessions
   */
  getAll(): CreativeData[] {
    return Array.from(this.data.values());
  }
  
  /**
   * Clear all data
   */
  clear(): void {
    this.data.clear();
    this.promptSessions.clear();
    this.techniqueSessions.clear();
  }
  
  /**
   * Get sessions by prompt similarity
   * @param prompt - The prompt to search for
   * @returns Array of sessions with similar prompts
   */
  getSimilarPrompts(prompt: string): CreativeData[] {
    const promptLower = prompt.toLowerCase();
    return this.filter(session => 
      session.prompt.toLowerCase().includes(promptLower) ||
      promptLower.includes(session.prompt.toLowerCase())
    );
  }
  
  /**
   * Get sessions using a specific technique
   * @param technique - The creative technique
   * @returns Array of sessions using that technique
   */
  getByTechnique(technique: string): CreativeData[] {
    const sessionIds = this.techniqueSessions.get(technique);
    if (!sessionIds) return [];
    
    return Array.from(sessionIds)
      .map(id => this.get(id))
      .filter((session): session is CreativeData => session !== undefined);
  }
  
  /**
   * Get all unique techniques used
   * @returns Array of technique names
   */
  getAllTechniques(): string[] {
    return Array.from(this.techniqueSessions.keys());
  }
  
  /**
   * Get active sessions needing more ideas
   * @returns Array of active sessions
   */
  getActiveSessions(): CreativeData[] {
    return this.filter(session => session.nextIdeaNeeded);
  }
  
  /**
   * Get sessions with the most ideas
   * @param limit - Number of top sessions to return
   * @returns Array of most productive sessions
   */
  getMostProductiveSessions(limit: number = 5): CreativeData[] {
    return this.getAll()
      .sort((a, b) => b.ideas.length - a.ideas.length)
      .slice(0, limit);
  }
  
  /**
   * Get sessions with the most insights
   * @param limit - Number of top sessions to return
   * @returns Array of most insightful sessions
   */
  getMostInsightfulSessions(limit: number = 5): CreativeData[] {
    return this.getAll()
      .sort((a, b) => b.insights.length - a.insights.length)
      .slice(0, limit);
  }
  
  /**
   * Calculate creativity metrics for a session
   * @param sessionId - The session identifier
   * @returns Creativity metrics
   */
  getCreativityMetrics(sessionId: string): Record<string, any> | undefined {
    const session = this.get(sessionId);
    if (!session) return undefined;
    
    return {
      ideaCount: session.ideas.length,
      techniqueCount: session.techniques.length,
      connectionCount: session.connections.length,
      insightCount: session.insights.length,
      ideaDiversity: this.calculateIdeaDiversity(session.ideas),
      connectionDensity: session.ideas.length > 0 
        ? session.connections.length / session.ideas.length 
        : 0,
      insightRatio: session.ideas.length > 0
        ? session.insights.length / session.ideas.length
        : 0
    };
  }
  
  /**
   * Calculate idea diversity (unique words ratio)
   * @param ideas - Array of ideas
   * @returns Diversity score
   */
  private calculateIdeaDiversity(ideas: string[]): number {
    if (ideas.length === 0) return 0;
    
    const allWords = new Set<string>();
    let totalWords = 0;
    
    ideas.forEach(idea => {
      const words = idea.toLowerCase().split(/\s+/);
      words.forEach(word => {
        allWords.add(word);
        totalWords++;
      });
    });
    
    return totalWords > 0 ? allWords.size / totalWords : 0;
  }
  
  /**
   * Find cross-pollination opportunities
   * @param sessionId - The session identifier
   * @returns Sessions with overlapping techniques or themes
   */
  findCrossPollination(sessionId: string): CreativeData[] {
    const session = this.get(sessionId);
    if (!session) return [];
    
    const related = new Set<string>();
    
    // Find sessions using similar techniques
    session.techniques.forEach(technique => {
      const sessionIds = this.techniqueSessions.get(technique);
      if (sessionIds) {
        sessionIds.forEach(id => {
          if (id !== sessionId) related.add(id);
        });
      }
    });
    
    return Array.from(related)
      .map(id => this.get(id))
      .filter((s): s is CreativeData => s !== undefined);
  }
  
  /**
   * Get overall statistics
   * @returns Comprehensive statistics
   */
  getStatistics(): Record<string, any> {
    const sessions = this.getAll();
    
    return {
      totalSessions: sessions.length,
      activeSessions: this.getActiveSessions().length,
      totalIdeas: sessions.reduce((sum, s) => sum + s.ideas.length, 0),
      totalInsights: sessions.reduce((sum, s) => sum + s.insights.length, 0),
      totalConnections: sessions.reduce((sum, s) => sum + s.connections.length, 0),
      averageIdeasPerSession: sessions.length > 0
        ? sessions.reduce((sum, s) => sum + s.ideas.length, 0) / sessions.length
        : 0,
      uniqueTechniques: this.getAllTechniques().length,
      techniqueUsage: this.getTechniqueUsage(),
      topTechniques: this.getTopTechniques(5)
    };
  }
  
  /**
   * Get technique usage counts
   */
  private getTechniqueUsage(): Record<string, number> {
    const usage: Record<string, number> = {};
    
    this.techniqueSessions.forEach((sessions, technique) => {
      usage[technique] = sessions.size;
    });
    
    return usage;
  }
  
  /**
   * Get most used techniques
   * @param limit - Number of top techniques
   * @returns Array of technique names and counts
   */
  private getTopTechniques(limit: number): Array<{ technique: string; count: number }> {
    const usage = this.getTechniqueUsage();
    
    return Object.entries(usage)
      .map(([technique, count]) => ({ technique, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, limit);
  }
}


================================================
FILE: src/state/stores/DebuggingStore.ts
================================================
/**
 * Store for managing debugging session data
 */

import { BaseStore } from './BaseStore.js';
import { DebuggingSession } from '../../types/index.js';

/**
 * Specialized store for managing debugging sessions
 */
export class DebuggingStore extends BaseStore<DebuggingSession> {
  /** Map of approach names to their sessions */
  private approachSessions: Map<string, DebuggingSession[]>;
  
  /** Map of issue keywords to related sessions */
  private issueIndex: Map<string, Set<string>>;
  
  constructor() {
    super('DebuggingStore');
    this.approachSessions = new Map();
    this.issueIndex = new Map();
  }
  
  /**
   * Add a new debugging session
   * @param id - Unique identifier
   * @param session - The debugging session data
   */
  add(id: string, session: DebuggingSession): void {
    this.data.set(id, session);
    
    // Track by approach
    const sessions = this.approachSessions.get(session.approachName) || [];
    sessions.push(session);
    this.approachSessions.set(session.approachName, sessions);
    
    // Index by issue keywords
    this.indexIssue(id, session.issue);
  }
  
  /**
   * Index issue keywords for search
   * @param sessionId - Session identifier
   * @param issue - Issue description
   */
  private indexIssue(sessionId: string, issue: string): void {
    // Extract keywords (simple tokenization)
    const keywords = issue.toLowerCase()
      .split(/\s+/)
      .filter(word => word.length > 3); // Only index words > 3 chars
    
    keywords.forEach(keyword => {
      const sessions = this.issueIndex.get(keyword) || new Set();
      sessions.add(sessionId);
      this.issueIndex.set(keyword, sessions);
    });
  }
  
  /**
   * Get all debugging sessions
   * @returns Array of all sessions
   */
  getAll(): DebuggingSession[] {
    return Array.from(this.data.values());
  }
  
  /**
   * Clear all data
   */
  clear(): void {
    this.data.clear();
    this.approachSessions.clear();
    this.issueIndex.clear();
  }
  
  /**
   * Get sessions by approach
   * @param approachName - The debugging approach name
   * @returns Array of sessions using that approach
   */
  getByApproach(approachName: DebuggingSession['approachName']): DebuggingSession[] {
    return this.approachSessions.get(approachName) || [];
  }
  
  /**
   * Search sessions by issue keywords
   * @param keywords - Keywords to search for
   * @returns Array of matching sessions
   */
  searchByIssue(keywords: string): DebuggingSession[] {
    const searchTerms = keywords.toLowerCase().split(/\s+/);
    const matchingIds = new Set<string>();
    
    searchTerms.forEach(term => {
      const sessions = this.issueIndex.get(term);
      if (sessions) {
        sessions.forEach(id => matchingIds.add(id));
      }
    });
    
    return Array.from(matchingIds)
      .map(id => this.get(id))
      .filter((session): session is DebuggingSession => session !== undefined);
  }
  
  /**
   * Get successfully resolved sessions
   * @returns Array of sessions with resolutions
   */
  getResolvedSessions(): DebuggingSession[] {
    return this.filter(session => 
      session.resolution.trim().length > 0
    );
  }
  
  /**
   * Get statistics about debugging approaches
   * @returns Statistics object
   */
  getStatistics(): {
    totalSessions: number;
    resolvedSessions: number;
    approachUsage: Record<string, number>;
    successRate: number;
  } {
    const resolved = this.getResolvedSessions();
    const stats: Record<string, number> = {};
    
    this.approachSessions.forEach((sessions, approach) => {
      stats[approach] = sessions.length;
    });
    
    return {
      totalSessions: this.size(),
      resolvedSessions: resolved.length,
      approachUsage: stats,
      successRate: this.size() > 0 ? resolved.length / this.size() : 0
    };
  }
  
  /**
   * Get the most effective approach based on resolution rate
   * @returns Approach with highest success rate
   */
  getMostEffectiveApproach(): { approach: string; successRate: number } | undefined {
    let bestApproach: string | undefined;
    let bestRate = 0;
    
    this.approachSessions.forEach((sessions, approach) => {
      const resolved = sessions.filter(s => s.resolution && s.resolution.trim().length > 0);
      const rate = sessions.length > 0 ? resolved.length / sessions.length : 0;
      
      if (rate > bestRate) {
        bestRate = rate;
        bestApproach = approach;
      }
    });
    
    return bestApproach ? { approach: bestApproach, successRate: bestRate } : undefined;
  }
}


================================================
FILE: src/state/stores/DecisionStore.ts
================================================
/**
 * Store for managing decision framework data
 */

import { BaseStore } from './BaseStore.js';
import { DecisionData, DecisionOption, DecisionCriterion } from '../../types/index.js';

/**
 * Specialized store for managing decision-making sessions
 */
export class DecisionStore extends BaseStore<DecisionData> {
  /** Map of decision statements to their sessions */
  private decisionIndex: Map<string, Set<string>>;
  
  /** Map of analysis types to their sessions */
  private analysisSessions: Map<string, DecisionData[]>;
  
  constructor() {
    super('DecisionStore');
    this.decisionIndex = new Map();
    this.analysisSessions = new Map();
  }
  
  /**
   * Add a new decision session
   * @param id - Unique identifier
   * @param decision - The decision data
   */
  add(id: string, decision: DecisionData): void {
    this.data.set(id, decision);
    
    // Index by decision keywords
    this.indexDecision(id, decision.decisionStatement);
    
    // Track by analysis type
    const sessions = this.analysisSessions.get(decision.analysisType) || [];
    sessions.push(decision);
    this.analysisSessions.set(decision.analysisType, sessions);
  }
  
  /**
   * Index decision keywords for search
   * @param decisionId - Decision identifier
   * @param statement - Decision statement
   */
  private indexDecision(decisionId: string, statement: string): void {
    const keywords = statement.toLowerCase()
      .split(/\s+/)
      .filter(word => word.length > 3);
    
    keywords.forEach(keyword => {
      const decisions = this.decisionIndex.get(keyword) || new Set();
      decisions.add(decisionId);
      this.decisionIndex.set(keyword, decisions);
    });
  }
  
  /**
   * Get all decision sessions
   * @returns Array of all sessions
   */
  getAll(): DecisionData[] {
    return Array.from(this.data.values());
  }
  
  /**
   * Clear all data
   */
  clear(): void {
    this.data.clear();
    this.decisionIndex.clear();
    this.analysisSessions.clear();
  }
  
  /**
   * Search decisions by keywords
   * @param keywords - Keywords to search for
   * @returns Array of matching decisions
   */
  searchDecisions(keywords: string): DecisionData[] {
    const searchTerms = keywords.toLowerCase().split(/\s+/);
    const matchingIds = new Set<string>();
    
    searchTerms.forEach(term => {
      const decisions = this.decisionIndex.get(term);
      if (decisions) {
        decisions.forEach(id => matchingIds.add(id));
      }
    });
    
    return Array.from(matchingIds)
      .map(id => this.get(id))
      .filter((decision): decision is DecisionData => decision !== undefined);
  }
  
  /**
   * Get decisions by analysis type
   * @param analysisType - The type of analysis
   * @returns Array of decisions using that analysis
   */
  getByAnalysisType(analysisType: DecisionData['analysisType']): DecisionData[] {
    return this.analysisSessions.get(analysisType) || [];
  }
  
  /**
   * Get decisions by stage
   * @param stage - The decision stage
   * @returns Array of decisions in that stage
   */
  getByStage(stage: DecisionData['stage']): DecisionData[] {
    return this.filter(decision => decision.stage === stage);
  }
  
  /**
   * Get completed decisions (with recommendations)
   * @returns Array of completed decisions
   */
  getCompletedDecisions(): DecisionData[] {
    return this.filter(decision => 
      !!(decision.recommendation && decision.recommendation.trim().length > 0)
    );
  }
  
  /**
   * Get active decisions (needing next stage)
   * @returns Array of active decisions
   */
  getActiveDecisions(): DecisionData[] {
    return this.filter(decision => decision.nextStageNeeded);
  }
  
  /**
   * Calculate decision quality score
   * @param decisionId - The decision identifier
   * @returns Quality score and breakdown
   */
  getDecisionQuality(decisionId: string): Record<string, any> | undefined {
    const decision = this.get(decisionId);
    if (!decision) return undefined;
    
    const quality = {
      hasMultipleOptions: decision.options.length > 1,
      hasCriteria: (decision.criteria?.length || 0) > 0,
      hasEvaluations: (decision.criteriaEvaluations?.length || 0) > 0,
      hasStakeholders: (decision.stakeholders?.length || 0) > 0,
      hasConstraints: (decision.constraints?.length || 0) > 0,
      hasOutcomes: (decision.possibleOutcomes?.length || 0) > 0,
      hasInformationGaps: (decision.informationGaps?.length || 0) > 0,
      hasSensitivityAnalysis: (decision.sensitivityInsights?.length || 0) > 0,
      hasRecommendation: !!decision.recommendation
    };
    
    const score = Object.values(quality).filter(v => v).length / Object.keys(quality).length;
    
    return {
      score,
      breakdown: quality,
      completeness: `${Math.round(score * 100)}%`
    };
  }
  
  /**
   * Get the best option based on scores
   * @param decisionId - The decision identifier
   * @returns The best option or undefined
   */
  getBestOption(decisionId: string): DecisionOption | undefined {
    const decision = this.get(decisionId);
    if (!decision) return undefined;
    
    // Check different scoring methods
    if (decision.expectedValues) {
      const bestId = Object.entries(decision.expectedValues)
        .reduce((best, [id, value]) => 
          value > (decision.expectedValues![best] || -Infinity) ? id : best
        , '');
      
      return decision.options.find(opt => opt.id === bestId);
    }
    
    if (decision.multiCriteriaScores) {
      const bestId = Object.entries(decision.multiCriteriaScores)
        .reduce((best, [id, score]) => 
          score > (decision.multiCriteriaScores![best] || -Infinity) ? id : best
        , '');
      
      return decision.options.find(opt => opt.id === bestId);
    }
    
    return undefined;
  }
  
  /**
   * Get overall statistics
   * @returns Comprehensive statistics
   */
  getStatistics(): Record<string, any> {
    const decisions = this.getAll();
    const completed = this.getCompletedDecisions();
    
    return {
      totalDecisions: decisions.length,
      completedDecisions: completed.length,
      activeDecisions: this.getActiveDecisions().length,
      completionRate: decisions.length > 0 ? completed.length / decisions.length : 0,
      averageOptions: decisions.length > 0
        ? decisions.reduce((sum, d) => sum + d.options.length, 0) / decisions.length
        : 0,
      averageCriteria: decisions.length > 0
        ? decisions.reduce((sum, d) => sum + (d.criteria?.length || 0), 0) / decisions.length
        : 0,
      analysisTypeDistribution: this.getAnalysisTypeDistribution(),
      stageDistribution: this.getStageDistribution()
    };
  }
  
  /**
   * Get distribution by analysis type
   */
  private getAnalysisTypeDistribution(): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    this.analysisSessions.forEach((sessions, type) => {
      distribution[type] = sessions.length;
    });
    
    return distribution;
  }
  
  /**
   * Get distribution by stage
   */
  private getStageDistribution(): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    this.forEach(decision => {
      distribution[decision.stage] = (distribution[decision.stage] || 0) + 1;
    });
    
    return distribution;
  }
}


================================================
FILE: src/state/stores/MentalModelStore.ts
================================================
/**
 * Store for managing mental model application data
 */

import { BaseStore } from './BaseStore.js';
import { MentalModelData } from '../../types/index.js';

/**
 * Specialized store for managing mental model applications
 */
export class MentalModelStore extends BaseStore<MentalModelData> {
  /** Map of model names to their applications */
  private modelApplications: Map<string, MentalModelData[]>;
  
  constructor() {
    super('MentalModelStore');
    this.modelApplications = new Map();
  }
  
  /**
   * Add a new mental model application
   * @param id - Unique identifier
   * @param model - The mental model data
   */
  add(id: string, model: MentalModelData): void {
    this.data.set(id, model);
    
    // Track by model name
    const applications = this.modelApplications.get(model.modelName) || [];
    applications.push(model);
    this.modelApplications.set(model.modelName, applications);
  }
  
  /**
   * Get all mental model applications
   * @returns Array of all applications
   */
  getAll(): MentalModelData[] {
    return Array.from(this.data.values());
  }
  
  /**
   * Clear all data
   */
  clear(): void {
    this.data.clear();
    this.modelApplications.clear();
  }
  
  /**
   * Get applications of a specific model
   * @param modelName - The name of the mental model
   * @returns Array of applications for that model
   */
  getByModel(modelName: MentalModelData['modelName']): MentalModelData[] {
    return this.modelApplications.get(modelName) || [];
  }
  
  /**
   * Get all unique problems analyzed
   * @returns Array of unique problem statements
   */
  getUniqueProblems(): string[] {
    const problems = new Set<string>();
    this.data.forEach(model => problems.add(model.problem));
    return Array.from(problems);
  }
  
  /**
   * Get statistics about model usage
   * @returns Object with usage counts per model
   */
  getStatistics(): Record<string, number> {
    const stats: Record<string, number> = {};
    this.modelApplications.forEach((applications, modelName) => {
      stats[modelName] = applications.length;
    });
    return stats;
  }
  
  /**
   * Find models applied to similar problems
   * @param problem - The problem to search for
   * @returns Array of models applied to similar problems
   */
  findSimilarApplications(problem: string): MentalModelData[] {
    const problemLower = problem.toLowerCase();
    return this.filter(model => 
      model.problem.toLowerCase().includes(problemLower) ||
      problemLower.includes(model.problem.toLowerCase())
    );
  }
  
  /**
   * Get the most frequently used model
   * @returns The model name and count, or undefined
   */
  getMostUsedModel(): { modelName: string; count: number } | undefined {
    let maxCount = 0;
    let mostUsed: string | undefined;
    
    this.modelApplications.forEach((applications, modelName) => {
      if (applications.length > maxCount) {
        maxCount = applications.length;
        mostUsed = modelName;
      }
    });
    
    return mostUsed ? { modelName: mostUsed, count: maxCount } : undefined;
  }
}


================================================
FILE: src/state/stores/MetacognitiveStore.ts
================================================
/**
 * Store for managing metacognitive monitoring data
 */

import { BaseStore } from './BaseStore.js';
import { MetacognitiveData, KnowledgeAssessment, ClaimAssessment } from '../../types/index.js';

/**
 * Specialized store for managing metacognitive monitoring sessions
 */
export class MetacognitiveStore extends BaseStore<MetacognitiveData> {
  /** Map of tasks to their monitoring sessions */
  private taskSessions: Map<string, MetacognitiveData[]>;
  
  /** Map of domains to knowledge assessments */
  private domainKnowledge: Map<string, KnowledgeAssessment[]>;
  
  constructor() {
    super('MetacognitiveStore');
    this.taskSessions = new Map();
    this.domainKnowledge = new Map();
  }
  
  /**
   * Add a new metacognitive monitoring session
   * @param id - Unique identifier
   * @param session - The metacognitive data
   */
  add(id: string, session: MetacognitiveData): void {
    this.data.set(id, session);
    
    // Track by task
    const sessions = this.taskSessions.get(session.task) || [];
    sessions.push(session);
    this.taskSessions.set(session.task, sessions);
    
    // Track knowledge assessments by domain
    if (session.knowledgeAssessment) {
      const assessments = this.domainKnowledge.get(session.knowledgeAssessment.domain) || [];
      assessments.push(session.knowledgeAssessment);
      this.domainKnowledge.set(session.knowledgeAssessment.domain, assessments);
    }
  }
  
  /**
   * Get all metacognitive sessions
   * @returns Array of all sessions
   */
  getAll(): MetacognitiveData[] {
    return Array.from(this.data.values());
  }
  
  /**
   * Clear all data
   */
  clear(): void {
    this.data.clear();
    this.taskSessions.clear();
    this.domainKnowledge.clear();
  }
  
  /**
   * Get sessions by task
   * @param task - The task being monitored
   * @returns Array of monitoring sessions for that task
   */
  getByTask(task: string): MetacognitiveData[] {
    const taskLower = task.toLowerCase();
    return this.filter(session => 
      session.task.toLowerCase().includes(taskLower)
    );
  }
  
  /**
   * Get sessions by stage
   * @param stage - The monitoring stage
   * @returns Array of sessions in that stage
   */
  getByStage(stage: MetacognitiveData['stage']): MetacognitiveData[] {
    return this.filter(session => session.stage === stage);
  }
  
  /**
   * Get knowledge assessments for a domain
   * @param domain - The knowledge domain
   * @returns Array of assessments for that domain
   */
  getKnowledgeByDomain(domain: string): KnowledgeAssessment[] {
    return this.domainKnowledge.get(domain) || [];
  }
  
  /**
   * Get all unique domains assessed
   * @returns Array of domain names
   */
  getAssessedDomains(): string[] {
    return Array.from(this.domainKnowledge.keys());
  }
  
  /**
   * Get sessions with low confidence
   * @param threshold - Confidence threshold (default: 0.5)
   * @returns Array of low-confidence sessions
   */
  getLowConfidenceSessions(threshold: number = 0.5): MetacognitiveData[] {
    return this.filter(session => session.overallConfidence < threshold);
  }
  
  /**
   * Get sessions with high uncertainty
   * @param minAreas - Minimum number of uncertainty areas (default: 3)
   * @returns Array of high-uncertainty sessions
   */
  getHighUncertaintySessions(minAreas: number = 3): MetacognitiveData[] {
    return this.filter(session => session.uncertaintyAreas.length >= minAreas);
  }
  
  /**
   * Get active sessions needing assessment
   * @returns Array of active sessions
   */
  getActiveSessions(): MetacognitiveData[] {
    return this.filter(session => session.nextAssessmentNeeded);
  }
  
  /**
   * Analyze confidence trends across iterations
   * @param monitoringId - The monitoring session ID
   * @returns Confidence trend data
   */
  getConfidenceTrend(monitoringId: string): Array<{ iteration: number; confidence: number }> | undefined {
    const sessions = this.filter(session => session.monitoringId === monitoringId);
    if (sessions.length === 0) return undefined;
    
    return sessions
      .sort((a, b) => a.iteration - b.iteration)
      .map(session => ({
        iteration: session.iteration,
        confidence: session.overallConfidence
      }));
  }
  
  /**
   * Get claim assessment statistics
   * @returns Statistics about claims
   */
  getClaimStatistics(): Record<string, any> {
    const allClaims: ClaimAssessment[] = [];
    
    this.forEach(session => {
      if (session.claims) {
        allClaims.push(...session.claims);
      }
    });
    
    const stats = {
      totalClaims: allClaims.length,
      byStatus: {} as Record<string, number>,
      averageConfidence: 0,
      withAlternatives: 0
    };
    
    let totalConfidence = 0;
    
    allClaims.forEach(claim => {
      stats.byStatus[claim.status] = (stats.byStatus[claim.status] || 0) + 1;
      totalConfidence += claim.confidenceScore;
      if (claim.alternativeInterpretations && claim.alternativeInterpretations.length > 0) {
        stats.withAlternatives++;
      }
    });
    
    stats.averageConfidence = allClaims.length > 0 ? totalConfidence / allClaims.length : 0;
    
    return stats;
  }
  
  /**
   * Get overall statistics
   * @returns Comprehensive statistics
   */
  getStatistics(): Record<string, any> {
    const sessions = this.getAll();
    
    return {
      totalSessions: sessions.length,
      activeSessions: this.getActiveSessions().length,
      averageConfidence: sessions.length > 0
        ? sessions.reduce((sum, s) => sum + s.overallConfidence, 0) / sessions.length
        : 0,
      averageUncertaintyAreas: sessions.length > 0
        ? sessions.reduce((sum, s) => sum + s.uncertaintyAreas.length, 0) / sessions.length
        : 0,
      assessedDomains: this.getAssessedDomains().length,
      stageDistribution: this.getStageDistribution(),
      claimStats: this.getClaimStatistics()
    };
  }
  
  /**
   * Get distribution by stage
   */
  private getStageDistribution(): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    this.forEach(session => {
      distribution[session.stage] = (distribution[session.stage] || 0) + 1;
    });
    
    return distribution;
  }
}


================================================
FILE: src/state/stores/ScientificStore.ts
================================================
/**
 * Store for managing scientific inquiry data
 */

import { BaseStore } from './BaseStore.js';
import { ScientificInquiryData, HypothesisData, ExperimentData } from '../../types/index.js';

/**
 * Specialized store for managing scientific inquiry sessions
 */
export class ScientificStore extends BaseStore<ScientificInquiryData> {
  /** Map of inquiry IDs to their sessions */
  private inquirySessions: Map<string, ScientificInquiryData[]>;
  
  /** Map of hypothesis IDs to their data */
  private hypotheses: Map<string, HypothesisData>;
  
  /** Map of experiment IDs to their data */
  private experiments: Map<string, ExperimentData>;
  
  constructor() {
    super('ScientificStore');
    this.inquirySessions = new Map();
    this.hypotheses = new Map();
    this.experiments = new Map();
  }
  
  /**
   * Add a new scientific inquiry session
   * @param id - Unique identifier
   * @param inquiry - The scientific inquiry data
   */
  add(id: string, inquiry: ScientificInquiryData): void {
    this.data.set(id, inquiry);
    
    // Track by inquiry ID
    const sessions = this.inquirySessions.get(inquiry.inquiryId) || [];
    sessions.push(inquiry);
    this.inquirySessions.set(inquiry.inquiryId, sessions);
    
    // Track hypotheses
    if (inquiry.hypothesis) {
      this.hypotheses.set(inquiry.hypothesis.hypothesisId, inquiry.hypothesis);
    }
    
    // Track experiments
    if (inquiry.experiment) {
      this.experiments.set(inquiry.experiment.experimentId, inquiry.experiment);
    }
  }
  
  /**
   * Get all scientific inquiry sessions
   * @returns Array of all sessions
   */
  getAll(): ScientificInquiryData[] {
    return Array.from(this.data.values());
  }
  
  /**
   * Clear all data
   */
  clear(): void {
    this.data.clear();
    this.inquirySessions.clear();
    this.hypotheses.clear();
    this.experiments.clear();
  }
  
  /**
   * Get sessions by inquiry ID
   * @param inquiryId - The inquiry identifier
   * @returns Array of sessions for that inquiry
   */
  getByInquiry(inquiryId: string): ScientificInquiryData[] {
    return this.inquirySessions.get(inquiryId) || [];
  }
  
  /**
   * Get sessions by stage
   * @param stage - The inquiry stage
   * @returns Array of sessions in that stage
   */
  getByStage(stage: ScientificInquiryData['stage']): ScientificInquiryData[] {
    return this.filter(inquiry => inquiry.stage === stage);
  }
  
  /**
   * Get hypothesis by ID
   * @param hypothesisId - The hypothesis identifier
   * @returns The hypothesis data or undefined
   */
  getHypothesis(hypothesisId: string): HypothesisData | undefined {
    return this.hypotheses.get(hypothesisId);
  }
  
  /**
   * Get experiment by ID
   * @param experimentId - The experiment identifier
   * @returns The experiment data or undefined
   */
  getExperiment(experimentId: string): ExperimentData | undefined {
    return this.experiments.get(experimentId);
  }
  
  /**
   * Get all hypotheses
   * @returns Array of all hypotheses
   */
  getAllHypotheses(): HypothesisData[] {
    return Array.from(this.hypotheses.values());
  }
  
  /**
   * Get all experiments
   * @returns Array of all experiments
   */
  getAllExperiments(): ExperimentData[] {
    return Array.from(this.experiments.values());
  }
  
  /**
   * Get hypotheses by status
   * @param status - The hypothesis status
   * @returns Array of hypotheses with that status
   */
  getHypothesesByStatus(status: HypothesisData['status']): HypothesisData[] {
    return this.getAllHypotheses().filter(h => h.status === status);
  }
  
  /**
   * Get experiments with matched outcomes
   * @returns Array of experiments where predictions matched
   */
  getSuccessfulExperiments(): ExperimentData[] {
    return this.getAllExperiments().filter(e => e.outcomeMatched === true);
  }
  
  /**
   * Get experiments with unexpected observations
   * @returns Array of experiments with unexpected results
   */
  getExperimentsWithSurprises(): ExperimentData[] {
    return this.getAllExperiments().filter(e => 
      e.unexpectedObservations && e.unexpectedObservations.length > 0
    );
  }
  
  /**
   * Get active inquiries needing next stage
   * @returns Array of active inquiries
   */
  getActiveInquiries(): ScientificInquiryData[] {
    return this.filter(inquiry => inquiry.nextStageNeeded);
  }
  
  /**
   * Get completed inquiries (reached conclusion)
   * @returns Array of completed inquiries
   */
  getCompletedInquiries(): ScientificInquiryData[] {
    return this.filter(inquiry => 
      !!(inquiry.conclusion && inquiry.conclusion.trim().length > 0)
    );
  }
  
  /**
   * Track the evolution of a hypothesis
   * @param hypothesisId - The hypothesis identifier
   * @returns Evolution history
   */
  getHypothesisEvolution(hypothesisId: string): HypothesisData[] {
    const evolution: HypothesisData[] = [];
    const hypothesis = this.hypotheses.get(hypothesisId);
    
    if (!hypothesis) return evolution;
    
    // Add the hypothesis itself
    evolution.push(hypothesis);
    
    // Find refinements
    this.getAllHypotheses().forEach(h => {
      if (h.refinementOf === hypothesisId) {
        evolution.push(h);
      }
    });
    
    return evolution.sort((a, b) => a.iteration - b.iteration);
  }
  
  /**
   * Get hypothesis-experiment pairs
   * @returns Array of paired hypotheses and experiments
   */
  getHypothesisExperimentPairs(): Array<{ hypothesis: HypothesisData; experiment: ExperimentData }> {
    const pairs: Array<{ hypothesis: HypothesisData; experiment: ExperimentData }> = [];
    
    this.experiments.forEach(experiment => {
      const hypothesis = this.hypotheses.get(experiment.hypothesisId);
      if (hypothesis) {
        pairs.push({ hypothesis, experiment });
      }
    });
    
    return pairs;
  }
  
  /**
   * Get overall statistics
   * @returns Comprehensive statistics
   */
  getStatistics(): Record<string, any> {
    const inquiries = this.getAll();
    const hypotheses = this.getAllHypotheses();
    const experiments = this.getAllExperiments();
    
    return {
      totalInquiries: inquiries.length,
      activeInquiries: this.getActiveInquiries().length,
      completedInquiries: this.getCompletedInquiries().length,
      totalHypotheses: hypotheses.length,
      supportedHypotheses: this.getHypothesesByStatus('supported').length,
      refutedHypotheses: this.getHypothesesByStatus('refuted').length,
      totalExperiments: experiments.length,
      successfulExperiments: this.getSuccessfulExperiments().length,
      experimentsWithSurprises: this.getExperimentsWithSurprises().length,
      stageDistribution: this.getStageDistribution(),
      hypothesisStatusDistribution: this.getHypothesisStatusDistribution(),
      averageConfidence: hypotheses.length > 0
        ? hypotheses.reduce((sum, h) => sum + h.confidence, 0) / hypotheses.length
        : 0
    };
  }
  
  /**
   * Get distribution by stage
   */
  private getStageDistribution(): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    this.forEach(inquiry => {
      distribution[inquiry.stage] = (distribution[inquiry.stage] || 0) + 1;
    });
    
    return distribution;
  }
  
  /**
   * Get hypothesis status distribution
   */
  private getHypothesisStatusDistribution(): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    this.getAllHypotheses().forEach(hypothesis => {
      distribution[hypothesis.status] = (distribution[hypothesis.status] || 0) + 1;
    });
    
    return distribution;
  }
}


================================================
FILE: src/state/stores/SystemsStore.ts
================================================
/**
 * Store for managing systems thinking data
 */

import { BaseStore } from './BaseStore.js';
import { SystemsData } from '../../types/index.js';

/**
 * Specialized store for managing systems thinking sessions
 */
export class SystemsStore extends BaseStore<SystemsData> {
  /** Map of system names to their analysis sessions */
  private systemAnalyses: Map<string, SystemsData[]>;
  
  /** Map of components to systems containing them */
  private componentIndex: Map<string, Set<string>>;
  
  constructor() {
    super('SystemsStore');
    this.systemAnalyses = new Map();
    this.componentIndex = new Map();
  }
  
  /**
   * Add a new systems thinking session
   * @param id - Unique identifier
   * @param system - The systems data
   */
  add(id: string, system: SystemsData): void {
    this.data.set(id, system);
    
    // Track by system name
    const analyses = this.systemAnalyses.get(system.system) || [];
    analyses.push(system);
    this.systemAnalyses.set(system.system, analyses);
    
    // Index components
    system.components.forEach(component => {
      const systems = this.componentIndex.get(component) || new Set();
      systems.add(id);
      this.componentIndex.set(component, systems);
    });
  }
  
  /**
   * Get all systems thinking sessions
   * @returns Array of all sessions
   */
  getAll(): SystemsData[] {
    return Array.from(this.data.values());
  }
  
  /**
   * Clear all data
   */
  clear(): void {
    this.data.clear();
    this.systemAnalyses.clear();
    this.componentIndex.clear();
  }
  
  /**
   * Get analyses for a specific system
   * @param systemName - The system name
   * @returns Array of analyses for that system
   */
  getBySystem(systemName: string): SystemsData[] {
    const exact = this.systemAnalyses.get(systemName) || [];
    
    // Also find partial matches
    const partial = this.filter(system => 
      system.system.toLowerCase().includes(systemName.toLowerCase()) &&
      !exact.includes(system)
    );
    
    return [...exact, ...partial];
  }
  
  /**
   * Get systems containing a specific component
   * @param component - The component name
   * @returns Array of systems containing that component
   */
  getSystemsWithComponent(component: string): SystemsData[] {
    const systemIds = this.componentIndex.get(component);
    if (!systemIds) return [];
    
    return Array.from(systemIds)
      .map(id => this.get(id))
      .filter((system): system is SystemsData => system !== undefined);
  }
  
  /**
   * Get all unique components across all systems
   * @returns Array of component names
   */
  getAllComponents(): string[] {
    return Array.from(this.componentIndex.keys());
  }
  
  /**
   * Get active sessions needing more analysis
   * @returns Array of active sessions
   */
  getActiveSessions(): SystemsData[] {
    return this.filter(system => system.nextAnalysisNeeded);
  }
  
  /**
   * Get systems with feedback loops
   * @returns Array of systems with identified feedback loops
   */
  getSystemsWithFeedbackLoops(): SystemsData[] {
    return this.filter(system => system.feedbackLoops.length > 0);
  }
  
  /**
   * Get systems with positive feedback loops
   * @returns Array of systems with reinforcing loops
   */
  getSystemsWithPositiveFeedback(): SystemsData[] {
    return this.filter(system => 
      system.feedbackLoops.some(loop => loop.type === 'positive')
    );
  }
  
  /**
   * Get systems with negative feedback loops
   * @returns Array of systems with balancing loops
   */
  getSystemsWithNegativeFeedback(): SystemsData[] {
    return this.filter(system => 
      system.feedbackLoops.some(loop => loop.type === 'negative')
    );
  }
  
  /**
   * Calculate system complexity metrics
   * @param sessionId - The session identifier
   * @returns Complexity metrics
   */
  getComplexityMetrics(sessionId: string): Record<string, any> | undefined {
    const system = this.get(sessionId);
    if (!system) return undefined;
    
    const totalRelationships = system.relationships.length;
    const totalComponents = system.components.length;
    
    return {
      componentCount: totalComponents,
      relationshipCount: totalRelationships,
      connectionDensity: totalComponents > 1 
        ? totalRelationships / (totalComponents * (totalComponents - 1) / 2)
        : 0,
      feedbackLoopCount: system.feedbackLoops.length,
      positiveFeedbackLoops: system.feedbackLoops.filter(l => l.type === 'positive').length,
      negativeFeedbackLoops: system.feedbackLoops.filter(l => l.type === 'negative').length,
      emergentPropertyCount: system.emergentProperties.length,
      leveragePointCount: system.leveragePoints.length,
      averageRelationshipStrength: this.calculateAverageRelationshipStrength(system),
      complexity: this.calculateComplexityScore(system)
    };
  }
  
  /**
   * Calculate average relationship strength
   * @param system - The system data
   * @returns Average strength or 0
   */
  private calculateAverageRelationshipStrength(system: SystemsData): number {
    const strengths = system.relationships
      .map(r => r.strength)
      .filter((s): s is number => s !== undefined);
    
    return strengths.length > 0 
      ? strengths.reduce((sum, s) => sum + s, 0) / strengths.length
      : 0;
  }
  
  /**
   * Calculate complexity score
   * @param system - The system data
   * @returns Complexity score (0-1)
   */
  private calculateComplexityScore(system: SystemsData): number {
    const factors = [
      Math.min(system.components.length / 20, 1), // Component count factor
      Math.min(system.relationships.length / 50, 1), // Relationship count factor
      Math.min(system.feedbackLoops.length / 10, 1), // Feedback loop factor
      Math.min(system.emergentProperties.length / 5, 1), // Emergent properties factor
      Math.min(system.leveragePoints.length / 5, 1) // Leverage points factor
    ];
    
    return factors.reduce((sum, f) => sum + f, 0) / factors.length;
  }
  
  /**
   * Find related systems (sharing components)
   * @param sessionId - The session identifier
   * @returns Array of related systems
   */
  findRelatedSystems(sessionId: string): SystemsData[] {
    const system = this.get(sessionId);
    if (!system) return [];
    
    const related = new Set<string>();
    
    // Find systems sharing components
    system.components.forEach(component => {
      const systemIds = this.componentIndex.get(component);
      if (systemIds) {
        systemIds.forEach(id => {
          if (id !== sessionId) related.add(id);
        });
      }
    });
    
    return Array.from(related)
      .map(id => this.get(id))
      .filter((s): s is SystemsData => s !== undefined);
  }
  
  /**
   * Get component co-occurrence matrix
   * @returns Map of component pairs to occurrence count
   */
  getComponentCoOccurrence(): Map<string, number> {
    const coOccurrence = new Map<string, number>();
    
    this.forEach(system => {
      // Generate all component pairs
      for (let i = 0; i < system.components.length; i++) {
        for (let j = i + 1; j < system.components.length; j++) {
          const pair = [system.components[i], system.components[j]].sort().join('::');
          coOccurrence.set(pair, (coOccurrence.get(pair) || 0) + 1);
        }
      }
    });
    
    return coOccurrence;
  }
  
  /**
   * Get overall statistics
   * @returns Comprehensive statistics
   */
  getStatistics(): Record<string, any> {
    const systems = this.getAll();
    
    return {
      totalSystems: systems.length,
      activeSystems: this.getActiveSessions().length,
      uniqueComponents: this.getAllComponents().length,
      systemsWithFeedback: this.getSystemsWithFeedbackLoops().length,
      totalFeedbackLoops: systems.reduce((sum, s) => sum + s.feedbackLoops.length, 0),
      totalEmergentProperties: systems.reduce((sum, s) => sum + s.emergentProperties.length, 0),
      totalLeveragePoints: systems.reduce((sum, s) => sum + s.leveragePoints.length, 0),
      averageComponents: systems.length > 0
        ? systems.reduce((sum, s) => sum + s.components.length, 0) / systems.length
        : 0,
      averageRelationships: systems.length > 0
        ? systems.reduce((sum, s) => sum + s.relationships.length, 0) / systems.length
        : 0,
      mostCommonComponents: this.getMostCommonComponents(5)
    };
  }
  
  /**
   * Get most common components
   * @param limit - Number of top components
   * @returns Array of components and counts
   */
  private getMostCommonComponents(limit: number): Array<{ component: string; count: number }> {
    const counts: Record<string, number> = {};
    
    this.componentIndex.forEach((systems, component) => {
      counts[component] = systems.size;
    });
    
    return Object.entries(counts)
      .map(([component, count]) => ({ component, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, limit);
  }
}


================================================
FILE: src/state/stores/ThoughtStore.ts
================================================
/**
 * Store for managing sequential thinking data with branching support
 */

import { BaseStore } from './BaseStore.js';
import { ThoughtData } from '../../types/index.js';

/**
 * Specialized store for managing thoughts with branching and revision support
 */
export class ThoughtStore extends BaseStore<ThoughtData> {
  /** Map of branch IDs to their thoughts */
  private branches: Map<string, ThoughtData[]>;
  
  /** Map of thought numbers to their revision history */
  private revisions: Map<number, ThoughtData[]>;
  
  constructor() {
    super('ThoughtStore');
    this.branches = new Map();
    this.revisions = new Map();
  }
  
  /**
   * Add a new thought to the store
   * @param id - Unique identifier for the thought
   * @param thought - The thought data to store
   */
  add(id: string, thought: ThoughtData): void {
    this.data.set(id, thought);
    
    // Track branches
    if (thought.branchId) {
      const branchThoughts = this.branches.get(thought.branchId) || [];
      branchThoughts.push(thought);
      this.branches.set(thought.branchId, branchThoughts);
    }
    
    // Track revisions
    if (thought.isRevision && thought.revisesThought !== undefined) {
      const revisionHistory = this.revisions.get(thought.revisesThought) || [];
      revisionHistory.push(thought);
      this.revisions.set(thought.revisesThought, revisionHistory);
    }
  }
  
  /**
   * Get all thoughts in chronological order
   * @returns Array of all thoughts
   */
  getAll(): ThoughtData[] {
    return Array.from(this.data.values()).sort((a, b) => 
      a.thoughtNumber - b.thoughtNumber
    );
  }
  
  /**
   * Clear all thoughts and associated data
   */
  clear(): void {
    this.data.clear();
    this.branches.clear();
    this.revisions.clear();
  }
  
  /**
   * Get thoughts for a specific branch
   * @param branchId - The branch identifier
   * @returns Array of thoughts in the branch
   */
  getBranch(branchId: string): ThoughtData[] {
    return this.branches.get(branchId) || [];
  }
  
  /**
   * Get all branches
   * @returns Map of branch IDs to their thoughts
   */
  getAllBranches(): Map<string, ThoughtData[]> {
    return new Map(this.branches);
  }
  
  /**
   * Get revision history for a thought
   * @param thoughtNumber - The original thought number
   * @returns Array of revisions for the thought
   */
  getRevisions(thoughtNumber: number): ThoughtData[] {
    return this.revisions.get(thoughtNumber) || [];
  }
  
  /**
   * Get the latest thought (highest thought number)
   * @returns The most recent thought or undefined
   */
  getLatest(): ThoughtData | undefined {
    const thoughts = this.getAll();
    return thoughts[thoughts.length - 1];
  }
  
  /**
   * Get thoughts in a specific range
   * @param start - Starting thought number (inclusive)
   * @param end - Ending thought number (inclusive)
   * @returns Array of thoughts in the range
   */
  getRange(start: number, end: number): ThoughtData[] {
    return this.getAll().filter(thought => 
      thought.thoughtNumber >= start && thought.thoughtNumber <= end
    );
  }
  
  /**
   * Get thoughts that need continuation
   * @returns Array of thoughts where nextThoughtNeeded is true
   */
  getPendingThoughts(): ThoughtData[] {
    return this.filter(thought => thought.nextThoughtNeeded);
  }
  
  /**
   * Count thoughts by type
   * @returns Object with counts for regular, revision, and branched thoughts
   */
  getStatistics(): {
    total: number;
    regular: number;
    revisions: number;
    branched: number;
    branches: number;
  } {
    const thoughts = this.getAll();
    return {
      total: thoughts.length,
      regular: thoughts.filter(t => !t.isRevision && !t.branchId).length,
      revisions: thoughts.filter(t => t.isRevision).length,
      branched: thoughts.filter(t => t.branchId).length,
      branches: this.branches.size
    };
  }
  
  /**
   * Export store data including branch and revision metadata
   */
  export(): Record<string, any> {
    return {
      thoughts: super.export(),
      branches: Object.fromEntries(this.branches),
      revisions: Object.fromEntries(
        Array.from(this.revisions).map(([k, v]) => [k.toString(), v])
      )
    };
  }
  
  /**
   * Import store data including branch and revision metadata
   */
  import(data: Record<string, any>): void {
    if (data.thoughts) {
      super.import(data.thoughts);
    }
    
    // Rebuild branch and revision maps
    this.branches.clear();
    this.revisions.clear();
    
    this.data.forEach((thought) => {
      if (thought.branchId) {
        const branchThoughts = this.branches.get(thought.branchId) || [];
        branchThoughts.push(thought);
        this.branches.set(thought.branchId, branchThoughts);
      }
      
      if (thought.isRevision && thought.revisesThought !== undefined) {
        const revisionHistory = this.revisions.get(thought.revisesThought) || [];
        revisionHistory.push(thought);
        this.revisions.set(thought.revisesThought, revisionHistory);
      }
    });
  }
}


================================================
FILE: src/state/stores/VisualStore.ts
================================================
/**
 * Store for managing visual reasoning data
 */

import { BaseStore } from './BaseStore.js';
import { VisualData, VisualElement } from '../../types/index.js';

/**
 * Specialized store for managing visual reasoning sessions
 */
export class VisualStore extends BaseStore<VisualData> {
  /** Map of diagram IDs to their operations */
  private diagramOperations: Map<string, VisualData[]>;
  
  /** Map of diagram types to their sessions */
  private diagramTypes: Map<string, Set<string>>;
  
  /** Current state of all diagrams (latest elements) */
  private diagramStates: Map<string, VisualElement[]>;
  
  constructor() {
    super('VisualStore');
    this.diagramOperations = new Map();
    this.diagramTypes = new Map();
    this.diagramStates = new Map();
  }
  
  /**
   * Add a new visual reasoning operation
   * @param id - Unique identifier
   * @param visual - The visual data
   */
  add(id: string, visual: VisualData): void {
    this.data.set(id, visual);
    
    // Track by diagram ID
    const operations = this.diagramOperations.get(visual.diagramId) || [];
    operations.push(visual);
    this.diagramOperations.set(visual.diagramId, operations);
    
    // Track by diagram type
    const diagrams = this.diagramTypes.get(visual.diagramType) || new Set();
    diagrams.add(visual.diagramId);
    this.diagramTypes.set(visual.diagramType, diagrams);
    
    // Update diagram state
    this.updateDiagramState(visual);
  }
  
  /**
   * Update the current state of a diagram based on operation
   * @param visual - The visual operation
   */
  private updateDiagramState(visual: VisualData): void {
    const currentState = this.diagramStates.get(visual.diagramId) || [];
    
    switch (visual.operation) {
      case 'create':
        if (visual.elements) {
          this.diagramStates.set(visual.diagramId, [...currentState, ...visual.elements]);
        }
        break;
        
      case 'update':
        if (visual.elements) {
          const updatedState = [...currentState];
          visual.elements.forEach(newElement => {
            const index = updatedState.findIndex(e => e.id === newElement.id);
            if (index >= 0) {
              updatedState[index] = newElement;
            } else {
              updatedState.push(newElement);
            }
          });
          this.diagramStates.set(visual.diagramId, updatedState);
        }
        break;
        
      case 'delete':
        if (visual.elements) {
          const deletedIds = new Set(visual.elements.map(e => e.id));
          const filteredState = currentState.filter(e => !deletedIds.has(e.id));
          this.diagramStates.set(visual.diagramId, filteredState);
        }
        break;
        
      case 'transform':
        // Transformations are handled like updates
        if (visual.elements) {
          const transformedState = [...currentState];
          visual.elements.forEach(element => {
            const index = transformedState.findIndex(e => e.id === element.id);
            if (index >= 0) {
              transformedState[index] = element;
            }
          });
          this.diagramStates.set(visual.diagramId, transformedState);
        }
        break;
    }
  }
  
  /**
   * Get all visual reasoning operations
   * @returns Array of all operations
   */
  getAll(): VisualData[] {
    return Array.from(this.data.values());
  }
  
  /**
   * Clear all data
   */
  clear(): void {
    this.data.clear();
    this.diagramOperations.clear();
    this.diagramTypes.clear();
    this.diagramStates.clear();
  }
  
  /**
   * Get operations for a specific diagram
   * @param diagramId - The diagram identifier
   * @returns Array of operations for that diagram
   */
  getByDiagram(diagramId: string): VisualData[] {
    return this.diagramOperations.get(diagramId) || [];
  }
  
  /**
   * Get all diagram IDs of a specific type
   * @param diagramType - The type of diagram
   * @returns Array of diagram IDs
   */
  getDiagramsByType(diagramType: VisualData['diagramType']): string[] {
    const diagrams = this.diagramTypes.get(diagramType);
    return diagrams ? Array.from(diagrams) : [];
  }
  
  /**
   * Get current state of a diagram
   * @param diagramId - The diagram identifier
   * @returns Current elements in the diagram
   */
  getDiagramState(diagramId: string): VisualElement[] {
    return this.diagramStates.get(diagramId) || [];
  }
  
  /**
   * Get operations by type
   * @param operation - The operation type
   * @returns Array of operations of that type
   */
  getByOperation(operation: VisualData['operation']): VisualData[] {
    return this.filter(visual => visual.operation === operation);
  }
  
  /**
   * Get active sessions needing next operation
   * @returns Array of active sessions
   */
  getActiveSessions(): VisualData[] {
    return this.filter(visual => visual.nextOperationNeeded);
  }
  
  /**
   * Get operations with insights
   * @returns Array of operations that generated insights
   */
  getInsightfulOperations(): VisualData[] {
    return this.filter(visual => 
      !!(visual.insight && visual.insight.trim().length > 0)
    );
  }
  
  /**
   * Get operations with hypotheses
   * @returns Array of operations that formed hypotheses
   */
  getHypothesisOperations(): VisualData[] {
    return this.filter(visual => 
      !!(visual.hypothesis && visual.hypothesis.trim().length > 0)
    );
  }
  
  /**
   * Calculate diagram complexity
   * @param diagramId - The diagram identifier
   * @returns Complexity metrics
   */
  getDiagramComplexity(diagramId: string): Record<string, any> {
    const state = this.getDiagramState(diagramId);
    const operations = this.getByDiagram(diagramId);
    
    const nodes = state.filter(e => e.type === 'node');
    const edges = state.filter(e => e.type === 'edge');
    const containers = state.filter(e => e.type === 'container');
    const annotations = state.filter(e => e.type === 'annotation');
    
    return {
      totalElements: state.length,
      nodeCount: nodes.length,
      edgeCount: edges.length,
      containerCount: containers.length,
      annotationCount: annotations.length,
      operationCount: operations.length,
      connectionDensity: nodes.length > 1 
        ? edges.length / (nodes.length * (nodes.length - 1) / 2)
        : 0,
      transformationCount: operations.filter(o => o.operation === 'transform').length,
      insightCount: operations.filter(o => o.insight).length,
      hypothesisCount: operations.filter(o => o.hypothesis).length
    };
  }
  
  /**
   * Get diagram evolution timeline
   * @param diagramId - The diagram identifier
   * @returns Timeline of operations
   */
  getDiagramTimeline(diagramId: string): Array<{
    iteration: number;
    operation: string;
    elementCount: number;
    hasInsight: boolean;
    hasHypothesis: boolean;
  }> {
    const operations = this.getByDiagram(diagramId);
    
    return operations
      .sort((a, b) => a.iteration - b.iteration)
      .map(op => ({
        iteration: op.iteration,
        operation: op.operation,
        elementCount: op.elements?.length || 0,
        hasInsight: !!op.insight,
        hasHypothesis: !!op.hypothesis
      }));
  }
  
  /**
   * Find similar diagrams based on structure
   * @param diagramId - The diagram identifier
   * @returns Array of similar diagram IDs
   */
  findSimilarDiagrams(diagramId: string): string[] {
    const targetState = this.getDiagramState(diagramId);
    const targetComplexity = this.getDiagramComplexity(diagramId);
    
    const similar: Array<{ id: string; similarity: number }> = [];
    
    this.diagramStates.forEach((state, id) => {
      if (id === diagramId) return;
      
      const complexity = this.getDiagramComplexity(id);
      
      // Simple similarity based on element counts
      const nodeDiff = Math.abs(complexity.nodeCount - targetComplexity.nodeCount);
      const edgeDiff = Math.abs(complexity.edgeCount - targetComplexity.edgeCount);
      
      const similarity = 1 / (1 + nodeDiff + edgeDiff);
      
      if (similarity > 0.5) {
        similar.push({ id, similarity });
      }
    });
    
    return similar
      .sort((a, b) => b.similarity - a.similarity)
      .map(s => s.id);
  }
  
  /**
   * Get overall statistics
   * @returns Comprehensive statistics
   */
  getStatistics(): Record<string, any> {
    const operations = this.getAll();
    const diagrams = Array.from(this.diagramStates.keys());
    
    return {
      totalOperations: operations.length,
      totalDiagrams: diagrams.length,
      activeOperations: this.getActiveSessions().length,
      operationDistribution: this.getOperationDistribution(),
      diagramTypeDistribution: this.getDiagramTypeDistribution(),
      insightfulOperations: this.getInsightfulOperations().length,
      hypothesisOperations: this.getHypothesisOperations().length,
      averageOperationsPerDiagram: diagrams.length > 0
        ? operations.length / diagrams.length
        : 0,
      averageElementsPerDiagram: diagrams.length > 0
        ? diagrams.reduce((sum, id) => sum + this.getDiagramState(id).length, 0) / diagrams.length
        : 0
    };
  }
  
  /**
   * Get distribution by operation type
   */
  private getOperationDistribution(): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    this.forEach(visual => {
      distribution[visual.operation] = (distribution[visual.operation] || 0) + 1;
    });
    
    return distribution;
  }
  
  /**
   * Get distribution by diagram type
   */
  private getDiagramTypeDistribution(): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    this.diagramTypes.forEach((diagrams, type) => {
      distribution[type] = diagrams.size;
    });
    
    return distribution;
  }
}


================================================
FILE: src/tools/collaborative-reasoning.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { CollaborativeSession, PersonaData, ContributionData } from '../types/index.js';

const PersonaSchema = z.object({
  id: z.string(),
  name: z.string(),
  expertise: z.array(z.string()),
  background: z.string(),
  perspective: z.string(),
  biases: z.array(z.string()),
  communication: z.object({
    style: z.enum(['formal', 'casual', 'technical', 'creative']),
    tone: z.enum(['analytical', 'supportive', 'challenging', 'neutral'])
  })
});

const ContributionSchema = z.object({
  personaId: z.string(),
  content: z.string(),
  type: z.enum(['observation', 'question', 'insight', 'concern', 'suggestion', 'challenge', 'synthesis']),
  confidence: z.number().min(0).max(1),
  referenceIds: z.array(z.string()).optional()
});

export function registerCollaborativeReasoning(server: McpServer, sessionState: SessionState) {
  server.tool(
    'collaborativereasoning',
    'Facilitate collaborative reasoning with multiple perspectives and personas',
    {
      topic: z.string(),
      personas: z.array(PersonaSchema),
      contributions: z.array(ContributionSchema),
      stage: z.enum(['problem-definition', 'ideation', 'critique', 'integration', 'decision', 'reflection']),
      activePersonaId: z.string(),
      sessionId: z.string(),
      iteration: z.number(),
      nextContributionNeeded: z.boolean()
    },
    async (args) => {
      const collaborativeData: CollaborativeSession = {
        topic: args.topic,
        personas: args.personas,
        contributions: args.contributions,
        stage: args.stage,
        activePersonaId: args.activePersonaId,
        sessionId: args.sessionId,
        iteration: args.iteration,
        nextContributionNeeded: args.nextContributionNeeded
      };
      
      sessionState.addCollaborativeSession(collaborativeData);
      
      // Get session context
      const stats = sessionState.getStats();
      const recentCollaborative = sessionState.getCollaborativeSessions().slice(-2);
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            topic: args.topic,
            stage: args.stage,
            activePersonaId: args.activePersonaId,
            contributionsCount: args.contributions.length,
            nextContributionNeeded: args.nextContributionNeeded,
            status: 'success',
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalCollaborativeSessions: stats.stores.collaborative.count || 0,
              recentSessions: recentCollaborative.map((c: CollaborativeSession) => ({
                topic: c.topic,
                stage: c.stage,
                contributionsCount: c.contributions.length
              }))
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/creative-thinking.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { CreativeData } from '../types/index.js';

export function registerCreativeThinking(server: McpServer, sessionState: SessionState) {
  server.tool(
    'creativethinking',
    'Engage in creative and lateral thinking approaches',
    {
      prompt: z.string().describe('Creative prompt or challenge'),
      ideas: z.array(z.string()).describe('Ideas generated'),
      techniques: z.array(z.string()).describe('Techniques used'),
      connections: z.array(z.string()).describe('Connections made'),
      insights: z.array(z.string()).describe('Novel insights'),
      sessionId: z.string().describe('Session identifier'),
      iteration: z.number().describe('Current iteration'),
      nextIdeaNeeded: z.boolean().describe('Whether more creativity is needed')
    },
    async (args) => {
      const creativeData: CreativeData = {
        prompt: args.prompt,
        ideas: args.ideas,
        techniques: args.techniques,
        connections: args.connections,
        insights: args.insights,
        sessionId: args.sessionId,
        iteration: args.iteration,
        nextIdeaNeeded: args.nextIdeaNeeded
      };
      
      sessionState.addCreativeSession(creativeData);
      
      // Get session context
      const stats = sessionState.getStats();
      const creativeSessions = sessionState.getCreativeSessions();
      const recentSessions = creativeSessions.slice(-3);
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            prompt: args.prompt,
            ideasGenerated: args.ideas.length,
            techniquesUsed: args.techniques,
            connectionsFound: args.connections.length,
            insights: args.insights,
            nextIdeaNeeded: args.nextIdeaNeeded,
            status: 'success',
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalCreativeSessions: creativeSessions.length,
              recentPrompts: recentSessions.map(s => ({
                prompt: s.prompt,
                ideasCount: s.ideas.length,
                iteration: s.iteration
              }))
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/debugging-approach.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { DebuggingApproachData } from '../types/index.js';

export function registerDebuggingApproach(server: McpServer, sessionState: SessionState) {
  server.tool(
    'debuggingapproach',
    'Apply systematic debugging approaches to identify and resolve issues',
    {
      approachName: z.enum(['binary_search', 'reverse_engineering', 'divide_conquer', 'backtracking', 'cause_elimination', 'program_slicing']).describe('Debugging approach'),
      steps: z.array(z.string()).describe('Steps taken to debug'),
      resolution: z.string().describe('How the issue was resolved')
    },
    async (args) => {
      const debugData: DebuggingApproachData = {
        approachName: args.approachName,
        issue: 'Issue being debugged', // TODO: Add issue to schema
        steps: args.steps,
        findings: 'Findings during debugging', // TODO: Add findings to schema
        resolution: args.resolution
      };
      
      sessionState.addDebuggingSession(debugData);
      
      // Get session context
      const stats = sessionState.getStats();
      const recentDebugging = sessionState.getDebuggingSessions().slice(-3);
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            ...debugData,
            status: 'success',
            hasSteps: args.steps.length > 0,
            hasResolution: !!args.resolution,
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalDebuggingApproaches: stats.stores.debugging.count || 0,
              recentApproaches: recentDebugging.map(d => ({
                approachName: d.approachName,
                resolved: !!d.resolution
              }))
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/decision-framework.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { DecisionData } from '../types/index.js';

export function registerDecisionFramework(server: McpServer, sessionState: SessionState) {
  server.tool(
    'decisionframework',
    'Apply structured decision-making frameworks',
    {
      decisionStatement: z.string(),
      options: z.array(z.object({
        name: z.string(),
        description: z.string()
      })),
      analysisType: z.string(),
      stage: z.string(),
      decisionId: z.string(),
      iteration: z.number(),
      nextStageNeeded: z.boolean()
    },
    async (args) => {
      const decisionData: DecisionData = {
        decisionStatement: args.decisionStatement,
        options: args.options,
        analysisType: args.analysisType as DecisionData['analysisType'],
        stage: args.stage as DecisionData['stage'],
        decisionId: args.decisionId,
        iteration: args.iteration,
        nextStageNeeded: args.nextStageNeeded
      };
      
      sessionState.addDecision(decisionData);
      
      // Get session context
      const stats = sessionState.getStats();
      const recentDecisions = sessionState.getDecisions();
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            decisionId: args.decisionId,
            stage: args.stage,
            analysisType: args.analysisType,
            optionsCount: args.options.length,
            nextStageNeeded: args.nextStageNeeded,
            status: 'success',
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalOperations: stats.totalOperations,
              decisionStoreStats: stats.stores.decisions,
              recentDecisions: recentDecisions.slice(-3).map((d: DecisionData) => ({
                decisionId: d.decisionId,
                stage: d.stage,
                iteration: d.iteration
              }))
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/index.ts
================================================
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';

import { registerSequentialThinking } from './sequential-thinking.js';
import { registerMentalModel } from './mental-model.js';
import { registerDebuggingApproach } from './debugging-approach.js';
import { registerCollaborativeReasoning } from './collaborative-reasoning.js';
import { registerDecisionFramework } from './decision-framework.js';
import { registerMetacognitiveMonitoring } from './metacognitive.js';
import { registerSocraticMethod } from './socratic-method.js';
import { registerCreativeThinking } from './creative-thinking.js';
import { registerSystemsThinking } from './systems-thinking.js';
import { registerScientificMethod } from './scientific-method.js';
import { registerStructuredArgumentation } from './structured-argumentation.js';
import { registerVisualReasoning } from './visual-reasoning.js';
import { registerSessionManagement } from './session-management.js';

/**
 * Registers all Clear Thought tools with the provided MCP server instance
 * @param server - The MCP server instance
 * @param sessionState - The session state manager
 */
export function registerTools(server: McpServer, sessionState: SessionState): void {
  // Register all thinking and reasoning tools
  registerSequentialThinking(server, sessionState);
  registerMentalModel(server, sessionState);
  registerDebuggingApproach(server, sessionState);
  registerCollaborativeReasoning(server, sessionState);
  registerDecisionFramework(server, sessionState);
  registerMetacognitiveMonitoring(server, sessionState);
  registerSocraticMethod(server, sessionState);
  registerCreativeThinking(server, sessionState);
  registerSystemsThinking(server, sessionState);
  registerScientificMethod(server, sessionState);
  registerStructuredArgumentation(server, sessionState);
  registerVisualReasoning(server, sessionState);
  
  // Register session management tools
  registerSessionManagement(server, sessionState);
}


================================================
FILE: src/tools/mental-model.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { MentalModelData } from '../types/index.js';

export function registerMentalModel(server: McpServer, sessionState: SessionState) {
  server.tool(
    'mentalmodel',
    'Apply mental models to analyze problems systematically',
    {
      modelName: z.enum(['first_principles', 'opportunity_cost', 'error_propagation', 'rubber_duck', 'pareto_principle', 'occams_razor']).describe('Name of the mental model'),
      problem: z.string().describe('The problem being analyzed'),
      steps: z.array(z.string()).describe('Steps to apply the model'),
      reasoning: z.string().describe('Reasoning process'),
      conclusion: z.string().describe('Conclusions drawn')
    },
    async (args) => {
      const modelData: MentalModelData = {
        modelName: args.modelName,
        problem: args.problem,
        steps: args.steps,
        reasoning: args.reasoning,
        conclusion: args.conclusion
      };
      
      sessionState.addMentalModel(modelData);
      
      // Get session context
      const stats = sessionState.getStats();
      const allModels = sessionState.getMentalModels();
      const recentModels = allModels.slice(-3);
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            modelName: args.modelName,
            status: 'success',
            hasSteps: args.steps.length > 0,
            hasConclusion: !!args.conclusion,
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalMentalModels: allModels.length,
              recentModels: recentModels.map(m => ({
                modelName: m.modelName,
                problem: m.problem
              }))
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/metacognitive.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { MetacognitiveData } from '../types/index.js';

export function registerMetacognitiveMonitoring(server: McpServer, sessionState: SessionState) {
  server.tool(
    'metacognitivemonitoring',
    'Monitor and assess thinking processes and knowledge',
    {
      task: z.string(),
      stage: z.string(),
      overallConfidence: z.number(),
      uncertaintyAreas: z.array(z.string()),
      recommendedApproach: z.string(),
      monitoringId: z.string(),
      iteration: z.number(),
      nextAssessmentNeeded: z.boolean()
    },
    async (args) => {
      const metacognitiveData: MetacognitiveData = {
        task: args.task,
        stage: args.stage as MetacognitiveData['stage'],
        overallConfidence: args.overallConfidence,
        uncertaintyAreas: args.uncertaintyAreas,
        recommendedApproach: args.recommendedApproach,
        monitoringId: args.monitoringId,
        iteration: args.iteration,
        nextAssessmentNeeded: args.nextAssessmentNeeded
      };
      
      sessionState.addMetacognitive(metacognitiveData);
      
      // Get session context
      const stats = sessionState.getStats();
      const recentMonitoring = sessionState.getMetacognitiveSessions();
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            task: args.task,
            stage: args.stage,
            overallConfidence: args.overallConfidence,
            uncertaintyCount: args.uncertaintyAreas.length,
            nextAssessmentNeeded: args.nextAssessmentNeeded,
            status: 'success',
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalOperations: stats.totalOperations,
              metacognitiveStoreStats: stats.stores.metacognitive,
              recentSessions: recentMonitoring.slice(-3).map((m: MetacognitiveData) => ({
                task: m.task,
                stage: m.stage,
                confidence: m.overallConfidence,
                iteration: m.iteration
              }))
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/scientific-method.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { ScientificInquiryData } from '../types/index.js';

export function registerScientificMethod(server: McpServer, sessionState: SessionState) {
  server.tool(
    'scientificmethod',
    'Apply scientific method for systematic inquiry',
    {
      stage: z.enum(['observation', 'question', 'hypothesis', 'experiment', 'analysis', 'conclusion', 'iteration']).describe('Current stage'),
      observation: z.string().optional().describe('Initial observation'),
      question: z.string().optional().describe('Research question'),
      hypothesis: z.object({
        statement: z.string(),
        variables: z.array(z.object({
          name: z.string(),
          type: z.enum(['independent', 'dependent', 'controlled', 'confounding']),
          operationalization: z.string().optional()
        })),
        assumptions: z.array(z.string()),
        hypothesisId: z.string(),
        confidence: z.number(),
        domain: z.string(),
        iteration: z.number(),
        alternativeTo: z.array(z.string()).optional(),
        refinementOf: z.string().optional(),
        status: z.enum(['proposed', 'testing', 'supported', 'refuted', 'refined'])
      }).optional().describe('Hypothesis data'),
      experiment: z.object({
        design: z.string(),
        methodology: z.string(),
        predictions: z.array(z.object({
          if: z.string(),
          then: z.string(),
          else: z.string().optional()
        })),
        experimentId: z.string(),
        hypothesisId: z.string(),
        controlMeasures: z.array(z.string()),
        results: z.string().optional(),
        outcomeMatched: z.boolean().optional(),
        unexpectedObservations: z.array(z.string()).optional(),
        limitations: z.array(z.string()).optional(),
        nextSteps: z.array(z.string()).optional()
      }).optional().describe('Experiment data'),
      analysis: z.string().optional().describe('Analysis results'),
      conclusion: z.string().optional().describe('Conclusions drawn'),
      inquiryId: z.string().describe('Inquiry ID'),
      iteration: z.number().describe('Current iteration'),
      nextStageNeeded: z.boolean().describe('Whether next stage is needed')
    },
    async (args) => {
      const scientificData: ScientificInquiryData = {
        stage: args.stage,
        observation: args.observation,
        question: args.question,
        hypothesis: args.hypothesis,
        experiment: args.experiment,
        analysis: args.analysis,
        conclusion: args.conclusion,
        inquiryId: args.inquiryId,
        iteration: args.iteration,
        nextStageNeeded: args.nextStageNeeded
      };
      
      sessionState.addScientificInquiry(scientificData);
      
      // Get session context
      const stats = sessionState.getStats();
      const inquiries = sessionState.getScientificInquiries();
      const recentInquiries = inquiries.slice(-3);
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            inquiryId: args.inquiryId,
            stage: args.stage,
            iteration: args.iteration,
            nextStageNeeded: args.nextStageNeeded,
            status: 'success',
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalScientificInquiries: inquiries.length,
              recentInquiries: recentInquiries.map(s => ({
                inquiryId: s.inquiryId,
                stage: s.stage,
                iteration: s.iteration
              }))
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/sequential-thinking.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { ThoughtData } from '../types/index.js';

export function registerSequentialThinking(server: McpServer, sessionState: SessionState) {
  server.tool(
    'sequentialthinking',
    'Process sequential thoughts with branching, revision, and memory management capabilities',
    {
      thought: z.string().describe('The thought content'),
      thoughtNumber: z.number().describe('Current thought number in sequence'),
      totalThoughts: z.number().describe('Total expected thoughts in sequence'),
      nextThoughtNeeded: z.boolean().describe('Whether the next thought is needed'),
      isRevision: z.boolean().optional().describe('Whether this is a revision of a previous thought'),
      revisesThought: z.number().optional().describe('Which thought number this revises'),
      branchFromThought: z.number().optional().describe('Which thought this branches from'),
      branchId: z.string().optional().describe('Unique identifier for this branch'),
      needsMoreThoughts: z.boolean().optional().describe('Whether more thoughts are needed')
    },
    async (args) => {
      const thoughtData: ThoughtData = {
        thought: args.thought,
        thoughtNumber: args.thoughtNumber,
        totalThoughts: args.totalThoughts,
        nextThoughtNeeded: args.nextThoughtNeeded,
        isRevision: args.isRevision,
        revisesThought: args.revisesThought,
        branchFromThought: args.branchFromThought,
        branchId: args.branchId,
        needsMoreThoughts: args.needsMoreThoughts
      };
      
      const added = sessionState.addThought(thoughtData);
      
      // Get session context for the response
      const stats = sessionState.getStats();
      const allThoughts = sessionState.getThoughts();
      const recentThoughts = allThoughts.slice(-3);
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            ...thoughtData,
            status: added ? 'success' : 'limit_reached',
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalThoughts: allThoughts.length,
              remainingThoughts: sessionState.getRemainingThoughts(),
              recentThoughts: recentThoughts.map(t => ({
                thoughtNumber: t.thoughtNumber,
                isRevision: t.isRevision
              }))
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/session-management.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';

export function registerSessionManagement(server: McpServer, sessionState: SessionState) {
  // Session Info Tool
  server.tool(
    'session_info',
    'Get information about the current session including statistics and recent activity',
    {},
    async () => {
      const stats = sessionState.getStats();
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            sessionId: stats.sessionId,
            createdAt: stats.createdAt,
            lastAccessedAt: stats.lastAccessedAt,
            stats,
            status: 'success'
          }, null, 2)
        }]
      };
    }
  );

  // Session Export Tool
  server.tool(
    'session_export',
    'Export the entire session state for backup or sharing',
    {
      format: z.enum(['json', 'summary']).optional().describe('Export format (default: json)')
    },
    async (args) => {
      const format = args.format || 'json';
      
      if (format === 'json') {
        const exportData = sessionState.export();
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(exportData, null, 2)
          }]
        };
      } else {
        // Summary format
        const stats = sessionState.getStats();
        let summary = `Session Summary: ${sessionState.sessionId}\n`;
        summary += `Created: ${stats.createdAt.toISOString()}\n`;
        summary += `Last Activity: ${stats.lastAccessedAt.toISOString()}\n\n`;
        summary += `Statistics:\n`;
        summary += `- Total Thoughts: ${stats.thoughtCount}\n`;
        summary += `- Tools Used: ${stats.toolsUsed.join(', ')}\n`;
        summary += `- Total Operations: ${stats.totalOperations}\n`;
        summary += `- Remaining Thoughts: ${stats.remainingThoughts}\n`;
        summary += `- Active: ${stats.isActive}\n\n`;
        summary += `Store Statistics:\n`;
        summary += `- Thoughts: ${JSON.stringify(stats.stores.thoughts)}\n`;
        summary += `- Mental Models: ${JSON.stringify(stats.stores.mentalModels)}\n`;
        summary += `- Debugging: ${JSON.stringify(stats.stores.debugging)}\n`;
        summary += `- Collaborative: ${JSON.stringify(stats.stores.collaborative)}\n`;
        summary += `- Decisions: ${JSON.stringify(stats.stores.decisions)}\n`;
        summary += `- Metacognitive: ${JSON.stringify(stats.stores.metacognitive)}\n`;
        summary += `- Scientific: ${JSON.stringify(stats.stores.scientific)}\n`;
        summary += `- Creative: ${JSON.stringify(stats.stores.creative)}\n`;
        summary += `- Systems: ${JSON.stringify(stats.stores.systems)}\n`;
        summary += `- Visual: ${JSON.stringify(stats.stores.visual)}\n`;
        
        return {
          content: [{
            type: 'text',
            text: summary
          }]
        };
      }
    }
  );

  // Session Import Tool
  server.tool(
    'session_import',
    'Import a previously exported session state',
    {
      sessionData: z.string().describe('JSON string of exported session data'),
      merge: z.boolean().optional().describe('Whether to merge with existing session data (default: false)')
    },
    async (args) => {
      try {
        const importData = JSON.parse(args.sessionData);
        const merge = args.merge || false;
        
        if (!merge) {
          // Clear existing data before import
          sessionState.cleanup();
        }
        
        sessionState.import(importData);
        
        const stats = sessionState.getStats();
        
        return {
          content: [{
            type: 'text',
            text: JSON.stringify({
              status: 'success',
              message: merge ? 'Session data merged successfully' : 'Session data imported successfully',
              sessionId: sessionState.sessionId,
              stats
            }, null, 2)
          }]
        };
      } catch (error) {
        return {
          content: [{
            type: 'text',
            text: JSON.stringify({
              status: 'error',
              error: error instanceof Error ? error.message : 'Failed to import session data'
            }, null, 2)
          }]
        };
      }
    }
  );
}


================================================
FILE: src/tools/socratic-method.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { SocraticData } from '../types/index.js';

export function registerSocraticMethod(server: McpServer, sessionState: SessionState) {
  server.tool(
    'socraticmethod',
    'Guide inquiry through systematic questioning',
    {
      claim: z.string().describe('The main claim or topic being explored'),
      premises: z.array(z.string()).describe('Supporting premises or assumptions'),
      conclusion: z.string().describe('Conclusion or insight reached'),
      question: z.string().describe('Socratic question being asked'),
      stage: z.enum(['clarification', 'assumptions', 'evidence', 'perspectives', 'implications', 'questions']).describe('Method stage'),
      argumentType: z.enum(['deductive', 'inductive', 'abductive', 'analogical']).describe('Type of argument'),
      confidence: z.number().min(0).max(1).describe('Confidence level (0.0-1.0)'),
      sessionId: z.string().describe('Session identifier'),
      iteration: z.number().describe('Current iteration'),
      nextArgumentNeeded: z.boolean().describe('Whether next argument is needed')
    },
    async (args) => {
      // Create socratic data as a special type of argument
      const socraticData: SocraticData = {
        claim: args.claim,
        premises: args.premises,
        conclusion: args.conclusion,
        question: args.question,
        stage: args.stage,
        argumentType: args.argumentType,
        confidence: args.confidence,
        sessionId: args.sessionId,
        iteration: args.iteration,
        nextArgumentNeeded: args.nextArgumentNeeded
      };
      
      sessionState.addArgumentation(socraticData);
      
      // Get session context
      const stats = sessionState.getStats();
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            question: args.question,
            stage: args.stage,
            claim: args.claim,
            premises: args.premises,
            conclusion: args.conclusion,
            argumentType: args.argumentType,
            confidence: args.confidence,
            nextArgumentNeeded: args.nextArgumentNeeded,
            status: 'success',
            sessionContext: {
              sessionId: sessionState.sessionId,
              iteration: args.iteration,
              totalOperations: stats.totalOperations
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/structured-argumentation.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { ArgumentData } from '../types/index.js';

export function registerStructuredArgumentation(server: McpServer, sessionState: SessionState) {
  server.tool(
    'structuredargumentation',
    'Construct and analyze structured arguments',
    {
      claim: z.string(),
      premises: z.array(z.string()),
      conclusion: z.string(),
      argumentType: z.string(),
      confidence: z.number(),
      nextArgumentNeeded: z.boolean()
    },
    async (args) => {
      const argumentData: ArgumentData = {
        claim: args.claim,
        premises: args.premises,
        conclusion: args.conclusion,
        argumentType: args.argumentType as ArgumentData['argumentType'],
        confidence: args.confidence,
        nextArgumentNeeded: args.nextArgumentNeeded,
        sessionId: sessionState.sessionId,
        iteration: 1
      };
      
      // Store using the addArgumentation method
      sessionState.addArgumentation(argumentData);
      
      // Get session context
      const stats = sessionState.getStats();
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            claim: args.claim,
            premisesCount: args.premises.length,
            argumentType: args.argumentType,
            confidence: args.confidence,
            nextArgumentNeeded: args.nextArgumentNeeded,
            status: 'success',
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalOperations: stats.totalOperations,
              creativeStoreStats: stats.stores.creative
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/systems-thinking.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { SystemsData } from '../types/index.js';

export function registerSystemsThinking(server: McpServer, sessionState: SessionState) {
  server.tool(
    'systemsthinking',
    'Analyze complex systems and their interactions',
    {
      system: z.string().describe('System being analyzed'),
      components: z.array(z.string()).describe('Components identified'),
      relationships: z.array(z.object({
        from: z.string(),
        to: z.string(),
        type: z.string(),
        strength: z.number().optional()
      })).describe('Relationships between components'),
      feedbackLoops: z.array(z.object({
        components: z.array(z.string()),
        type: z.enum(['positive', 'negative']),
        description: z.string()
      })).describe('Feedback loops identified'),
      emergentProperties: z.array(z.string()).describe('Emergent properties'),
      leveragePoints: z.array(z.string()).describe('Leverage points'),
      sessionId: z.string().describe('Session ID'),
      iteration: z.number().describe('Current iteration'),
      nextAnalysisNeeded: z.boolean().describe('Whether more analysis is needed')
    },
    async (args) => {
      const systemsData: SystemsData = {
        system: args.system,
        components: args.components,
        relationships: args.relationships,
        feedbackLoops: args.feedbackLoops,
        emergentProperties: args.emergentProperties,
        leveragePoints: args.leveragePoints,
        sessionId: args.sessionId,
        iteration: args.iteration,
        nextAnalysisNeeded: args.nextAnalysisNeeded
      };
      
      sessionState.addSystemsAnalysis(systemsData);
      
      // Get session context
      const stats = sessionState.getStats();
      const systemsAnalyses = sessionState.getSystemsAnalyses();
      const recentAnalyses = systemsAnalyses.slice(-3);
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            system: args.system,
            componentsCount: args.components.length,
            relationshipsCount: args.relationships.length,
            feedbackLoops: args.feedbackLoops,
            emergentProperties: args.emergentProperties,
            leveragePoints: args.leveragePoints,
            nextAnalysisNeeded: args.nextAnalysisNeeded,
            status: 'success',
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalSystemsAnalyses: systemsAnalyses.length,
              recentAnalyses: recentAnalyses.map(a => ({
                system: a.system,
                componentsCount: a.components.length,
                iteration: a.iteration
              }))
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/tools/visual-reasoning.ts
================================================
import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import type { SessionState } from '../state/SessionState.js';
import type { VisualData } from '../types/index.js';

export function registerVisualReasoning(server: McpServer, sessionState: SessionState) {
  server.tool(
    'visualreasoning',
    'Process visual reasoning and diagram operations',
    {
      operation: z.string(),
      diagramId: z.string(),
      diagramType: z.string(),
      iteration: z.number(),
      nextOperationNeeded: z.boolean()
    },
    async (args) => {
      const visualData: VisualData = {
        operation: args.operation as VisualData['operation'],
        diagramId: args.diagramId,
        diagramType: args.diagramType as VisualData['diagramType'],
        iteration: args.iteration,
        nextOperationNeeded: args.nextOperationNeeded
      };
      
      sessionState.addVisualOperation(visualData);
      
      // Get session context
      const stats = sessionState.getStats();
      const recentVisuals = sessionState.getVisualOperations();
      
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            diagramId: args.diagramId,
            diagramType: args.diagramType,
            operation: args.operation,
            iteration: args.iteration,
            nextOperationNeeded: args.nextOperationNeeded,
            status: 'success',
            sessionContext: {
              sessionId: sessionState.sessionId,
              totalOperations: stats.totalOperations,
              visualStoreStats: stats.stores.visual,
              recentOperations: recentVisuals.slice(-3).map((v: VisualData) => ({
                diagramId: v.diagramId,
                operation: v.operation,
                iteration: v.iteration
              }))
            }
          }, null, 2)
        }]
      };
    }
  );
}


================================================
FILE: src/types/index.ts
================================================
/**
 * Type definitions for the Clear Thought MCP server
 * 
 * This file contains all the data structures used by the various thinking tools
 * in the Clear Thought MCP server.
 */

// ============================================================================
// Core Thinking Types
// ============================================================================

/**
 * Sequential thinking data structure
 * Represents a single thought in a sequential thinking process
 */
export interface ThoughtData {
  /** The content of the thought */
  thought: string;
  /** Current thought number in the sequence */
  thoughtNumber: number;
  /** Total expected thoughts in the sequence */
  totalThoughts: number;
  /** Whether this is a revision of a previous thought */
  isRevision?: boolean;
  /** Which thought number this revises */
  revisesThought?: number;
  /** Which thought this branches from */
  branchFromThought?: number;
  /** Unique identifier for this branch */
  branchId?: string;
  /** Whether more thoughts are needed beyond totalThoughts */
  needsMoreThoughts?: boolean;
  /** Whether the next thought in sequence is needed */
  nextThoughtNeeded: boolean;
}

/**
 * Mental model application data
 * Represents the application of a specific mental model to a problem
 */
export interface MentalModelData {
  /** Name of the mental model being applied */
  modelName: 'first_principles' | 'opportunity_cost' | 'error_propagation' | 
             'rubber_duck' | 'pareto_principle' | 'occams_razor';
  /** The problem being analyzed */
  problem: string;
  /** Steps taken to apply the model */
  steps: string[];
  /** Reasoning process */
  reasoning: string;
  /** Conclusions drawn from the analysis */
  conclusion: string;
}

/**
 * Debugging approach data
 * Represents a systematic debugging session
 */
export interface DebuggingApproachData {
  /** The debugging approach being used */
  approachName: 'binary_search' | 'reverse_engineering' | 'divide_conquer' | 
                'backtracking' | 'cause_elimination' | 'program_slicing';
  /** Description of the issue being debugged */
  issue: string;
  /** Steps taken during debugging */
  steps: string[];
  /** Findings discovered during the process */
  findings: string;
  /** How the issue was resolved */
  resolution: string;
}

/**
 * Debugging session data (alternative naming)
 */
export interface DebuggingSession extends DebuggingApproachData {}

// ============================================================================
// Collaborative Reasoning Types
// ============================================================================

/**
 * Persona definition for collaborative reasoning
 */
export interface PersonaData {
  /** Unique identifier for the persona */
  id: string;
  /** Name of the persona */
  name: string;
  /** Areas of expertise */
  expertise: string[];
  /** Background information */
  background: string;
  /** Perspective or viewpoint */
  perspective: string;
  /** Known biases */
  biases: string[];
  /** Communication preferences */
  communication: {
    /** Communication style */
    style: 'formal' | 'casual' | 'technical' | 'creative';
    /** Tone of communication */
    tone: 'analytical' | 'supportive' | 'challenging' | 'neutral';
  };
}

/**
 * Contribution from a persona in collaborative reasoning
 */
export interface ContributionData {
  /** ID of the persona making the contribution */
  personaId: string;
  /** Content of the contribution */
  content: string;
  /** Type of contribution */
  type: 'observation' | 'question' | 'insight' | 'concern' | 
        'suggestion' | 'challenge' | 'synthesis';
  /** Confidence level (0.0-1.0) */
  confidence: number;
  /** IDs of previous contributions this builds upon */
  referenceIds?: string[];
}

/**
 * Position in a disagreement
 */
export interface DisagreementPosition {
  /** ID of the persona holding this position */
  personaId: string;
  /** The position statement */
  position: string;
  /** Arguments supporting the position */
  arguments: string[];
}

/**
 * Resolution of a disagreement
 */
export interface DisagreementResolution {
  /** Type of resolution reached */
  type: 'consensus' | 'compromise' | 'integration' | 'tabled';
  /** Description of the resolution */
  description: string;
}

/**
 * Disagreement data structure
 */
export interface DisagreementData {
  /** Topic of disagreement */
  topic: string;
  /** Different positions */
  positions: DisagreementPosition[];
  /** Resolution if reached */
  resolution?: DisagreementResolution;
}

/**
 * Complete collaborative reasoning session
 */
export interface CollaborativeSession {
  /** Topic being discussed */
  topic: string;
  /** Personas participating */
  personas: PersonaData[];
  /** All contributions made */
  contributions: ContributionData[];
  /** Current stage of the process */
  stage: 'problem-definition' | 'ideation' | 'critique' | 
         'integration' | 'decision' | 'reflection';
  /** Currently active persona ID */
  activePersonaId: string;
  /** Next persona ID if determined */
  nextPersonaId?: string;
  /** Points of consensus reached */
  consensusPoints?: string[];
  /** Active disagreements */
  disagreements?: DisagreementData[];
  /** Key insights discovered */
  keyInsights?: string[];
  /** Questions still open */
  openQuestions?: string[];
  /** Final recommendation if reached */
  finalRecommendation?: string;
  /** Session identifier */
  sessionId: string;
  /** Current iteration number */
  iteration: number;
  /** Suggested types for next contribution */
  suggestedContributionTypes?: ContributionData['type'][];
  /** Whether next contribution is needed */
  nextContributionNeeded: boolean;
}

// ============================================================================
// Decision Framework Types
// ============================================================================

/**
 * Option in a decision
 */
export interface DecisionOption {
  /** Unique identifier */
  id?: string;
  /** Name of the option */
  name: string;
  /** Description of the option */
  description: string;
}

/**
 * Criterion for evaluating options
 */
export interface DecisionCriterion {
  /** Unique identifier */
  id?: string;
  /** Name of the criterion */
  name: string;
  /** Description of the criterion */
  description: string;
  /** Weight (0.0-1.0) */
  weight: number;
  /** How to evaluate this criterion */
  evaluationMethod: 'quantitative' | 'qualitative' | 'boolean';
}

/**
 * Evaluation of a criterion for an option
 */
export interface CriterionEvaluation {
  /** ID of the criterion */
  criterionId: string;
  /** ID of the option */
  optionId: string;
  /** Score (0.0-1.0) */
  score: number;
  /** Justification for the score */
  justification: string;
}

/**
 * Possible outcome of a decision
 */
export interface PossibleOutcome {
  /** Unique identifier */
  id?: string;
  /** Description of the outcome */
  description: string;
  /** Probability (0.0-1.0) */
  probability: number;
  /** Utility value */
  value: number;
  /** Associated option ID */
  optionId: string;
  /** Confidence in the estimate (0.0-1.0) */
  confidenceInEstimate: number;
}

/**
 * Information gap in decision making
 */
export interface InformationGap {
  /** Description of what's missing */
  description: string;
  /** Impact on decision (0.0-1.0) */
  impact: number;
  /** How to research this gap */
  researchMethod: string;
}

/**
 * Complete decision framework data
 */
export interface DecisionData {
  /** Statement of the decision to be made */
  decisionStatement: string;
  /** Available options */
  options: DecisionOption[];
  /** Evaluation criteria */
  criteria?: DecisionCriterion[];
  /** Stakeholders involved */
  stakeholders?: string[];
  /** Constraints on the decision */
  constraints?: string[];
  /** Time horizon for the decision */
  timeHorizon?: string;
  /** Risk tolerance level */
  riskTolerance?: 'risk-averse' | 'risk-neutral' | 'risk-seeking';
  /** Possible outcomes */
  possibleOutcomes?: PossibleOutcome[];
  /** Criteria evaluations */
  criteriaEvaluations?: CriterionEvaluation[];
  /** Information gaps identified */
  informationGaps?: InformationGap[];
  /** Type of analysis being performed */
  analysisType: 'expected-utility' | 'multi-criteria' | 'maximin' | 
                'minimax-regret' | 'satisficing';
  /** Current stage of the process */
  stage: 'problem-definition' | 'options' | 'criteria' | 
         'evaluation' | 'analysis' | 'recommendation';
  /** Final recommendation */
  recommendation?: string;
  /** Sensitivity analysis insights */
  sensitivityInsights?: string[];
  /** Expected values for options */
  expectedValues?: Record<string, number>;
  /** Multi-criteria scores */
  multiCriteriaScores?: Record<string, number>;
  /** Decision session ID */
  decisionId: string;
  /** Current iteration */
  iteration: number;
  /** Suggested next stage */
  suggestedNextStage?: string;
  /** Whether next stage is needed */
  nextStageNeeded: boolean;
}

// ============================================================================
// Metacognitive Monitoring Types
// ============================================================================

/**
 * Assessment of knowledge in a domain
 */
export interface KnowledgeAssessment {
  /** Domain being assessed */
  domain: string;
  /** Level of knowledge */
  knowledgeLevel: 'expert' | 'proficient' | 'familiar' | 
                  'basic' | 'minimal' | 'none';
  /** Confidence score (0.0-1.0) */
  confidenceScore: number;
  /** Evidence supporting the assessment */
  supportingEvidence: string;
  /** Known limitations */
  knownLimitations: string[];
  /** Relevant training cutoff date */
  relevantTrainingCutoff?: string;
}

/**
 * Assessment of a claim
 */
export interface ClaimAssessment {
  /** The claim being assessed */
  claim: string;
  /** Status of the claim */
  status: 'fact' | 'inference' | 'speculation' | 'uncertain';
  /** Confidence score (0.0-1.0) */
  confidenceScore: number;
  /** Basis for the evidence */
  evidenceBasis: string;
  /** How the claim could be falsified */
  falsifiabilityCriteria?: string;
  /** Alternative interpretations */
  alternativeInterpretations?: string[];
}

/**
 * Assessment of reasoning
 */
export interface ReasoningAssessment {
  /** The reasoning step */
  step: string;
  /** Potential biases identified */
  potentialBiases: string[];
  /** Assumptions made */
  assumptions: string[];
  /** Logical validity (0.0-1.0) */
  logicalValidity: number;
  /** Inference strength (0.0-1.0) */
  inferenceStrength: number;
}

/**
 * Complete metacognitive monitoring data
 */
export interface MetacognitiveData {
  /** Task being monitored */
  task: string;
  /** Current stage */
  stage: 'knowledge-assessment' | 'planning' | 'execution' | 
         'monitoring' | 'evaluation' | 'reflection';
  /** Knowledge assessment */
  knowledgeAssessment?: KnowledgeAssessment;
  /** Claims made */
  claims?: ClaimAssessment[];
  /** Reasoning steps */
  reasoningSteps?: ReasoningAssessment[];
  /** Overall confidence (0.0-1.0) */
  overallConfidence: number;
  /** Areas of uncertainty */
  uncertaintyAreas: string[];
  /** Recommended approach */
  recommendedApproach: string;
  /** Monitoring session ID */
  monitoringId: string;
  /** Current iteration */
  iteration: number;
  /** Suggested assessments */
  suggestedAssessments?: ('knowledge' | 'claim' | 'reasoning' | 'overall')[];
  /** Whether next assessment is needed */
  nextAssessmentNeeded: boolean;
}

// ============================================================================
// Scientific Method Types
// ============================================================================

/**
 * Variable in scientific inquiry
 */
export interface Variable {
  /** Name of the variable */
  name: string;
  /** Type of variable */
  type: 'independent' | 'dependent' | 'controlled' | 'confounding';
  /** How the variable is operationalized */
  operationalization?: string;
}

/**
 * Hypothesis data
 */
export interface HypothesisData {
  /** The hypothesis statement */
  statement: string;
  /** Variables involved */
  variables: Variable[];
  /** Assumptions made */
  assumptions: string[];
  /** Hypothesis ID */
  hypothesisId: string;
  /** Confidence (0.0-1.0) */
  confidence: number;
  /** Domain of the hypothesis */
  domain: string;
  /** Current iteration */
  iteration: number;
  /** Alternative hypotheses */
  alternativeTo?: string[];
  /** If this refines another hypothesis */
  refinementOf?: string;
  /** Current status */
  status: 'proposed' | 'testing' | 'supported' | 'refuted' | 'refined';
}

/**
 * Prediction from hypothesis
 */
export interface Prediction {
  /** If condition */
  if: string;
  /** Then outcome */
  then: string;
  /** Else outcome */
  else?: string;
}

/**
 * Experiment data
 */
export interface ExperimentData {
  /** Experiment design */
  design: string;
  /** Methodology used */
  methodology: string;
  /** Predictions made */
  predictions: Prediction[];
  /** Experiment ID */
  experimentId: string;
  /** Associated hypothesis ID */
  hypothesisId: string;
  /** Control measures */
  controlMeasures: string[];
  /** Results obtained */
  results?: string;
  /** Whether outcome matched predictions */
  outcomeMatched?: boolean;
  /** Unexpected observations */
  unexpectedObservations?: string[];
  /** Limitations identified */
  limitations?: string[];
  /** Next steps */
  nextSteps?: string[];
}

/**
 * Scientific inquiry session (not in backup files but in current implementation)
 */
export interface ScientificInquiryData {
  /** Current stage */
  stage: 'observation' | 'question' | 'hypothesis' | 
         'experiment' | 'analysis' | 'conclusion' | 'iteration';
  /** Initial observation */
  observation?: string;
  /** Research question */
  question?: string;
  /** Hypothesis */
  hypothesis?: HypothesisData;
  /** Experiment */
  experiment?: ExperimentData;
  /** Analysis results */
  analysis?: string;
  /** Conclusions drawn */
  conclusion?: string;
  /** Inquiry ID */
  inquiryId: string;
  /** Current iteration */
  iteration: number;
  /** Whether next stage is needed */
  nextStageNeeded: boolean;
}

// ============================================================================
// Argumentation Types
// ============================================================================

/**
 * Argument data structure
 */
export interface ArgumentData {
  /** The main claim */
  claim: string;
  /** Supporting premises */
  premises: string[];
  /** Conclusion drawn */
  conclusion: string;
  /** Argument ID */
  argumentId?: string;
  /** Type of argument */
  argumentType: 'deductive' | 'inductive' | 'abductive' | 'analogical';
  /** Confidence (0.0-1.0) */
  confidence: number;
  /** What this responds to */
  respondsTo?: string;
  /** Arguments this supports */
  supports?: string[];
  /** Arguments this contradicts */
  contradicts?: string[];
  /** Identified strengths */
  strengths?: string[];
  /** Identified weaknesses */
  weaknesses?: string[];
  /** Relevance score (0.0-1.0) */
  relevance?: number;
  /** Session ID */
  sessionId: string;
  /** Current iteration */
  iteration: number;
  /** Suggested next argument types */
  suggestedNextTypes?: ArgumentData['argumentType'][];
  /** Whether next argument is needed */
  nextArgumentNeeded: boolean;
}

/**
 * Socratic method data (derived from structured argumentation)
 */
export interface SocraticData extends ArgumentData {
  /** Question being explored */
  question?: string;
  /** Method stage */
  stage?: 'clarification' | 'assumptions' | 'evidence' | 
          'perspectives' | 'implications' | 'questions';
}

// ============================================================================
// Creative Thinking Types
// ============================================================================

/**
 * Creative thinking data
 * Note: Not found in backup files but exists in current implementation
 */
export interface CreativeData {
  /** Creative prompt or challenge */
  prompt: string;
  /** Ideas generated */
  ideas: string[];
  /** Techniques used */
  techniques: string[];
  /** Connections made */
  connections: string[];
  /** Novel insights */
  insights: string[];
  /** Session ID */
  sessionId: string;
  /** Current iteration */
  iteration: number;
  /** Whether more creativity is needed */
  nextIdeaNeeded: boolean;
}

// ============================================================================
// Systems Thinking Types
// ============================================================================

/**
 * Systems thinking data
 * Note: Not found in backup files but exists in current implementation
 */
export interface SystemsData {
  /** System being analyzed */
  system: string;
  /** Components identified */
  components: string[];
  /** Relationships between components */
  relationships: Array<{
    from: string;
    to: string;
    type: string;
    strength?: number;
  }>;
  /** Feedback loops identified */
  feedbackLoops: Array<{
    components: string[];
    type: 'positive' | 'negative';
    description: string;
  }>;
  /** Emergent properties */
  emergentProperties: string[];
  /** Leverage points */
  leveragePoints: string[];
  /** Session ID */
  sessionId: string;
  /** Current iteration */
  iteration: number;
  /** Whether more analysis is needed */
  nextAnalysisNeeded: boolean;
}

// ============================================================================
// Visual Reasoning Types
// ============================================================================

/**
 * Visual element in a diagram
 */
export interface VisualElement {
  /** Element ID */
  id: string;
  /** Type of element */
  type: 'node' | 'edge' | 'container' | 'annotation';
  /** Element label */
  label?: string;
  /** Additional properties */
  properties: Record<string, any>;
  /** Source node (for edges) */
  source?: string;
  /** Target node (for edges) */
  target?: string;
  /** Contained elements (for containers) */
  contains?: string[];
}

/**
 * Visual reasoning operation data
 */
export interface VisualData {
  /** Operation being performed */
  operation: 'create' | 'update' | 'delete' | 'transform' | 'observe';
  /** Elements involved */
  elements?: VisualElement[];
  /** Type of transformation */
  transformationType?: 'rotate' | 'move' | 'resize' | 'recolor' | 'regroup';
  /** Diagram ID */
  diagramId: string;
  /** Type of diagram */
  diagramType: 'concept-map' | 'flowchart' | 'mind-map' | 'timeline' | 'custom';
  /** Current iteration */
  iteration: number;
  /** Observation made */
  observation?: string;
  /** Insight gained */
  insight?: string;
  /** Hypothesis formed */
  hypothesis?: string;
  /** Whether next operation is needed */
  nextOperationNeeded: boolean;
}

// ============================================================================
// Session Management Types
// ============================================================================

/**
 * Session export format for import/export functionality
 */
export interface SessionExport {
  /** Export format version */
  version: string;
  /** Export timestamp */
  timestamp: string;
  /** Session ID */
  sessionId: string;
  /** Type of thinking session */
  sessionType: 'sequential' | 'mental-model' | 'debugging' | 'collaborative' |
               'decision' | 'metacognitive' | 'scientific' | 'socratic' |
               'creative' | 'systems' | 'visual';
  /** Session data (varies by type) */
  data: ThoughtData | MentalModelData | DebuggingSession | CollaborativeSession |
        DecisionData | MetacognitiveData | ScientificInquiryData | SocraticData |
        CreativeData | SystemsData | VisualData;
  /** Session metadata */
  metadata?: {
    /** User who created the session */
    user?: string;
    /** Tags for categorization */
    tags?: string[];
    /** Session description */
    description?: string;
    /** Custom metadata */
    custom?: Record<string, any>;
  };
}

/**
 * Result from processing a thinking operation
 */
export interface ProcessResult {
  /** Whether the operation succeeded */
  success: boolean;
  /** Content to return */
  content: Array<{
    type: 'text';
    text: string;
  }>;
  /** Error information if failed */
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}


================================================
FILE: src/utils/validation.ts
================================================
import Ajv from "ajv";
import { JSONSchema7 } from "json-schema";

const ajv = new (Ajv as any)({ allErrors: true });

export function validateWithErrors(data: unknown, schema: JSONSchema7): void {
  const validate = ajv.compile(schema);
  const valid = validate(data);
  
  if (!valid) {
    const errors = validate.errors || [];
    const errorMessages = errors.map((err: any) => {
      const path = err.instancePath || '';
      const message = err.message || 'Validation error';
      return path ? `${path}: ${message}` : message;
    });
    
    throw new Error(`Validation failed: ${errorMessages.join(', ')}`);
  }
}

